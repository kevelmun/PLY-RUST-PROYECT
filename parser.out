Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDE
    COMMENT
    DIVEQUAL
    HASH
    KW_ABSTRACT
    KW_AS
    KW_ASYNC
    KW_AWAIT
    KW_BECOME
    KW_BOX
    KW_BREAK
    KW_CHARACTER
    KW_CONTINUE
    KW_CRATE
    KW_DO
    KW_DYN
    KW_ENUM
    KW_EXPECT
    KW_EXTERN
    KW_FINAL
    KW_IMPL
    KW_LOOP
    KW_MACRO
    KW_MATCH
    KW_MOD
    KW_MOVE
    KW_OVERRIDE
    KW_PRIV
    KW_PUB
    KW_READ_LINE
    KW_REF
    KW_SELFTYPE
    KW_SELFVALUE
    KW_STATIC
    KW_STATICLIFETIME
    KW_STDIN
    KW_STRUCT
    KW_SUPER
    KW_TRAIT
    KW_TRY
    KW_TYPE
    KW_TYPEOF
    KW_UNION
    KW_UNSAFE
    KW_UNSIZED
    KW_USE
    KW_VIRTUAL
    KW_WHERE
    KW_YIELD
    LNOT
    MINUSEQUAL
    MODULUS
    MODULUSEQUAL
    ORE
    OREXE
    PLUSEQUAL
    QMARK
    TIMESEQUAL

Grammar

Rule 0     S' -> main_rule
Rule 1     main_rule -> father_rule
Rule 2     main_rule -> father_rule main_rule
Rule 3     father_rule -> print
Rule 4     father_rule -> dvariable
Rule 5     father_rule -> function
Rule 6     father_rule -> variables
Rule 7     father_rule -> control_str
Rule 8     father_rule -> expression
Rule 9     father_rule -> void
Rule 10    father_rule -> data_str
Rule 11    father_rule -> array
Rule 12    father_rule -> linkedlist_methods
Rule 13    father_rule -> hashmap_methods
Rule 14    father_rule -> initialization
Rule 15    expression -> expression PLUS expression
Rule 16    expression -> expression MINUS expression
Rule 17    expression -> expression TIMES expression
Rule 18    expression -> expression DIVIDE expression
Rule 19    expression -> LPAREN expression RPAREN
Rule 20    expression -> number
Rule 21    number -> INTEGER
Rule 22    number -> FLOAT
Rule 23    number -> VARIABLE
Rule 24    data_type -> UNSIG_INT_8
Rule 25    data_type -> UNSIG_INT_16
Rule 26    data_type -> UNSIG_INT_32
Rule 27    data_type -> UNSIG_INT_64
Rule 28    data_type -> UNSIG_INT_128
Rule 29    data_type -> SIG_INT_8
Rule 30    data_type -> SIG_INT_16
Rule 31    data_type -> SIG_INT_32
Rule 32    data_type -> SIG_INT_64
Rule 33    data_type -> SIG_INT_128
Rule 34    data_type -> FLOAT_32
Rule 35    data_type -> FLOAT_64
Rule 36    data_type -> KW_BOOLEAN
Rule 37    data_type -> KW_STRING
Rule 38    data -> CADENA
Rule 39    data -> INTEGER
Rule 40    data -> CHAR
Rule 41    data -> FLOAT
Rule 42    data -> KW_FALSE
Rule 43    data -> KW_TRUE
Rule 44    data -> tuple
Rule 45    comparator -> <empty>
Rule 46    comparator -> EQ
Rule 47    comparator -> NE
Rule 48    comparator -> GE
Rule 49    comparator -> LE
Rule 50    comparator -> GT
Rule 51    comparator -> LT
Rule 52    and -> VARIABLE LAND VARIABLE
Rule 53    conditional -> VARIABLE comparator data
Rule 54    conditional -> and comparator data
Rule 55    or -> VARIABLE LOR VARIABLE
Rule 56    mdata -> data
Rule 57    mdata -> data COMMA mdata
Rule 58    print -> KW_PRINT LPAREN CADENA RPAREN SEMI
Rule 59    dvariable -> KW_LET VARIABLE SEMI
Rule 60    array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
Rule 61    array -> LBRACKET mdata RBRACKET
Rule 62    variables -> VARIABLE
Rule 63    variables -> VARIABLE COMMA variables
Rule 64    while -> KW_WHILE LPAREN VARIABLE
Rule 65    tuple -> LPAREN mdata RPAREN
Rule 66    initialization -> let_initialization SEMI
Rule 67    initialization -> const_initialization SEMI
Rule 68    initialization -> data_str SEMI
Rule 69    let_initialization -> KW_LET VARIABLE EQUALS data
Rule 70    let_initialization -> KW_LET VARIABLE COLON data_type EQUALS data
Rule 71    let_initialization -> KW_LET KW_MUT VARIABLE EQUALS data
Rule 72    let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
Rule 73    let_initialization -> KW_LET VARIABLE EQUALS expression_var
Rule 74    let_initialization -> KW_LET VARIABLE COLON data_type EQUALS expression_var
Rule 75    let_initialization -> KW_LET KW_MUT VARIABLE EQUALS expression_var
Rule 76    let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
Rule 77    const_initialization -> KW_CONST VARIABLE COLON data_type EQUALS data
Rule 78    arguments -> void
Rule 79    arguments -> variables
Rule 80    function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
Rule 81    control_str -> for_str
Rule 82    control_str -> for_str_tagged
Rule 83    control_str -> if
Rule 84    control_str -> else
Rule 85    control_str -> else_if
Rule 86    control_str -> while
Rule 87    for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
Rule 88    for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
Rule 89    for_str_tagged -> label COLON for_str
Rule 90    range -> INTEGER DOT DOT INTEGER
Rule 91    range -> VARIABLE DOT DOT VARIABLE
Rule 92    label -> QUOTE VARIABLE
Rule 93    data_str -> array
Rule 94    data_str -> hashmap
Rule 95    data_str -> linkedlist
Rule 96    hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
Rule 97    hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
Rule 98    hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
Rule 99    hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
Rule 100   hashmap_methods -> VARIABLE hashmap_insert
Rule 101   hashmap_methods -> VARIABLE hashmap_remove
Rule 102   hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI
Rule 103   hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI
Rule 104   void -> <empty>
Rule 105   linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
Rule 106   linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
Rule 107   linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
Rule 108   linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
Rule 109   linkedlist_methods -> VARIABLE linkedlist_push
Rule 110   linkedlist_methods -> VARIABLE linkedlist_remove
Rule 111   linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI
Rule 112   linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI
Rule 113   if -> KW_IF conditional LBRACE main_rule RBRACE
Rule 114   else -> KW_ELSE LBRACE main_rule RBRACE
Rule 115   else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
Rule 116   function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
Rule 117   expression_var -> expression
Rule 118   expression_var -> VARIABLE
Rule 119   return -> main_rule
Rule 120   return -> main_rule KW_RETURN expression_var SEMI

Terminals, with rules where they appear

AND                  : 103
ANDE                 : 
CADENA               : 38 58
CHAR                 : 40
COLON                : 70 72 74 76 77 89 96 96 97 97 98 98 99 99 105 105 105 106 106 106 107 107 108 108
COMMA                : 57 63
COMMENT              : 
DIVEQUAL             : 
DIVIDE               : 18
DOT                  : 90 90 91 91 102 103 111 112
EQ                   : 46
EQUALS               : 60 69 70 71 72 73 74 75 76 77 96 97 98 99 105 106 107 108
FLOAT                : 22 41
FLOAT_32             : 34
FLOAT_64             : 35
GE                   : 48
GT                   : 50 105 106 116
HASH                 : 
INTEGER              : 21 39 90 90 112
KW_ABSTRACT          : 
KW_AS                : 
KW_ASYNC             : 
KW_AWAIT             : 
KW_BECOME            : 
KW_BOOLEAN           : 36
KW_BOX               : 
KW_BREAK             : 
KW_CHARACTER         : 
KW_CONST             : 77
KW_CONTINUE          : 
KW_CRATE             : 
KW_DO                : 
KW_DYN               : 
KW_ELSE              : 114 115
KW_ENUM              : 
KW_EXPECT            : 
KW_EXTERN            : 
KW_FALSE             : 42
KW_FINAL             : 
KW_FN                : 80 116
KW_FOR               : 87 88
KW_FROM              : 98 99 107 108
KW_HASHMAP           : 96 97 98 99
KW_IF                : 113 115
KW_IMPL              : 
KW_IN                : 87 88
KW_INSERT            : 102
KW_LET               : 59 60 69 70 71 72 73 74 75 76 96 97 98 99 105 106 107 108
KW_LINKEDLIST        : 105 105 106 106 107 108
KW_LOOP              : 
KW_MACRO             : 
KW_MATCH             : 
KW_MOD               : 
KW_MOVE              : 
KW_MUT               : 71 72 75 76 97 99 106 108
KW_NEW               : 96 97 105 106
KW_OVERRIDE          : 
KW_PRINT             : 58
KW_PRIV              : 
KW_PUB               : 
KW_PUSH_BACK         : 111
KW_READ_LINE         : 
KW_REF               : 
KW_REMOVE            : 103 112
KW_RETURN            : 120
KW_SELFTYPE          : 
KW_SELFVALUE         : 
KW_STATIC            : 
KW_STATICLIFETIME    : 
KW_STDIN             : 
KW_STRING            : 37
KW_STRUCT            : 
KW_SUPER             : 
KW_TRAIT             : 
KW_TRUE              : 43
KW_TRY               : 
KW_TYPE              : 
KW_TYPEOF            : 
KW_UNION             : 
KW_UNSAFE            : 
KW_UNSIZED           : 
KW_USE               : 
KW_VIRTUAL           : 
KW_WHERE             : 
KW_WHILE             : 64
KW_YIELD             : 
LAND                 : 52
LBRACE               : 80 87 88 113 114 115 116
LBRACKET             : 60 61
LE                   : 49
LNOT                 : 
LOR                  : 55
LPAREN               : 19 58 64 65 80 96 97 98 99 102 103 105 106 107 108 111 112 116
LT                   : 51 105 106
MINUS                : 16 116
MINUSEQUAL           : 
MODULUS              : 
MODULUSEQUAL         : 
NE                   : 47
ORE                  : 
OREXE                : 
PLUS                 : 15
PLUSEQUAL            : 
QMARK                : 
QUOTE                : 92
RBRACE               : 80 87 88 113 114 115 116
RBRACKET             : 60 61
RPAREN               : 19 58 65 80 96 97 98 99 102 103 105 106 107 108 111 112 116
SEMI                 : 58 59 66 67 68 102 103 111 112 120
SIG_INT_128          : 33
SIG_INT_16           : 30
SIG_INT_32           : 31
SIG_INT_64           : 32
SIG_INT_8            : 29
TIMES                : 17
TIMESEQUAL           : 
UNSIG_INT_128        : 28
UNSIG_INT_16         : 25
UNSIG_INT_32         : 26
UNSIG_INT_64         : 27
UNSIG_INT_8          : 24
VARIABLE             : 23 52 52 53 55 55 59 60 62 63 64 69 70 71 72 73 74 75 76 77 80 87 88 88 91 91 92 96 97 98 99 100 101 105 106 107 108 109 110 116 118
error                : 

Nonterminals, with rules where they appear

and                  : 54
arguments            : 80 116
array                : 11 93 98 99 107 108
comparator           : 53 54
conditional          : 113 115
const_initialization : 67
control_str          : 7
data                 : 53 54 56 57 69 70 71 72 77 103 111
data_str             : 10 68
data_type            : 70 72 74 76 77 105 106 116
dvariable            : 4
else                 : 84
else_if              : 85
expression           : 8 15 15 16 16 17 17 18 18 19 117
expression_var       : 73 74 75 76 120
father_rule          : 1 2
for_str              : 81 89
for_str_tagged       : 82
function             : 5
hashmap              : 94
hashmap_insert       : 100
hashmap_methods      : 13
hashmap_remove       : 101
if                   : 83
initialization       : 14
label                : 89
let_initialization   : 66
linkedlist           : 95
linkedlist_methods   : 12
linkedlist_push      : 109
linkedlist_remove    : 110
main_rule            : 2 80 87 88 113 114 115 119 120 0
mdata                : 57 60 61 65 102
number               : 20
or                   : 
print                : 3
range                : 87
return               : 116
tuple                : 44
variables            : 6 63 79
void                 : 9 78
while                : 86

Parsing method: LALR

state 0

    (0) S' -> . main_rule
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    $end            reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 1
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 1

    (0) S' -> main_rule .



state 2

    (1) main_rule -> father_rule .
    (2) main_rule -> father_rule . main_rule
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (main_rule -> father_rule .)
  ! reduce/reduce conflict for RBRACE resolved using rule 1 (main_rule -> father_rule .)
  ! reduce/reduce conflict for KW_RETURN resolved using rule 1 (main_rule -> father_rule .)
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    $end            reduce using rule 1 (main_rule -> father_rule .)
    RBRACE          reduce using rule 1 (main_rule -> father_rule .)
    KW_RETURN       reduce using rule 1 (main_rule -> father_rule .)
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]
  ! $end            [ reduce using rule 104 (void -> .) ]
  ! RBRACE          [ reduce using rule 104 (void -> .) ]
  ! KW_RETURN       [ reduce using rule 104 (void -> .) ]

    father_rule                    shift and go to state 2
    main_rule                      shift and go to state 41
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 3

    (3) father_rule -> print .

    KW_PRINT        reduce using rule 3 (father_rule -> print .)
    KW_LET          reduce using rule 3 (father_rule -> print .)
    KW_FN           reduce using rule 3 (father_rule -> print .)
    VARIABLE        reduce using rule 3 (father_rule -> print .)
    LPAREN          reduce using rule 3 (father_rule -> print .)
    LBRACKET        reduce using rule 3 (father_rule -> print .)
    KW_FOR          reduce using rule 3 (father_rule -> print .)
    KW_IF           reduce using rule 3 (father_rule -> print .)
    KW_ELSE         reduce using rule 3 (father_rule -> print .)
    KW_WHILE        reduce using rule 3 (father_rule -> print .)
    INTEGER         reduce using rule 3 (father_rule -> print .)
    FLOAT           reduce using rule 3 (father_rule -> print .)
    KW_CONST        reduce using rule 3 (father_rule -> print .)
    QUOTE           reduce using rule 3 (father_rule -> print .)
    $end            reduce using rule 3 (father_rule -> print .)
    RBRACE          reduce using rule 3 (father_rule -> print .)
    KW_RETURN       reduce using rule 3 (father_rule -> print .)


state 4

    (4) father_rule -> dvariable .

    KW_PRINT        reduce using rule 4 (father_rule -> dvariable .)
    KW_LET          reduce using rule 4 (father_rule -> dvariable .)
    KW_FN           reduce using rule 4 (father_rule -> dvariable .)
    VARIABLE        reduce using rule 4 (father_rule -> dvariable .)
    LPAREN          reduce using rule 4 (father_rule -> dvariable .)
    LBRACKET        reduce using rule 4 (father_rule -> dvariable .)
    KW_FOR          reduce using rule 4 (father_rule -> dvariable .)
    KW_IF           reduce using rule 4 (father_rule -> dvariable .)
    KW_ELSE         reduce using rule 4 (father_rule -> dvariable .)
    KW_WHILE        reduce using rule 4 (father_rule -> dvariable .)
    INTEGER         reduce using rule 4 (father_rule -> dvariable .)
    FLOAT           reduce using rule 4 (father_rule -> dvariable .)
    KW_CONST        reduce using rule 4 (father_rule -> dvariable .)
    QUOTE           reduce using rule 4 (father_rule -> dvariable .)
    $end            reduce using rule 4 (father_rule -> dvariable .)
    RBRACE          reduce using rule 4 (father_rule -> dvariable .)
    KW_RETURN       reduce using rule 4 (father_rule -> dvariable .)


state 5

    (5) father_rule -> function .

    KW_PRINT        reduce using rule 5 (father_rule -> function .)
    KW_LET          reduce using rule 5 (father_rule -> function .)
    KW_FN           reduce using rule 5 (father_rule -> function .)
    VARIABLE        reduce using rule 5 (father_rule -> function .)
    LPAREN          reduce using rule 5 (father_rule -> function .)
    LBRACKET        reduce using rule 5 (father_rule -> function .)
    KW_FOR          reduce using rule 5 (father_rule -> function .)
    KW_IF           reduce using rule 5 (father_rule -> function .)
    KW_ELSE         reduce using rule 5 (father_rule -> function .)
    KW_WHILE        reduce using rule 5 (father_rule -> function .)
    INTEGER         reduce using rule 5 (father_rule -> function .)
    FLOAT           reduce using rule 5 (father_rule -> function .)
    KW_CONST        reduce using rule 5 (father_rule -> function .)
    QUOTE           reduce using rule 5 (father_rule -> function .)
    $end            reduce using rule 5 (father_rule -> function .)
    RBRACE          reduce using rule 5 (father_rule -> function .)
    KW_RETURN       reduce using rule 5 (father_rule -> function .)


state 6

    (6) father_rule -> variables .

    KW_PRINT        reduce using rule 6 (father_rule -> variables .)
    KW_LET          reduce using rule 6 (father_rule -> variables .)
    KW_FN           reduce using rule 6 (father_rule -> variables .)
    VARIABLE        reduce using rule 6 (father_rule -> variables .)
    LPAREN          reduce using rule 6 (father_rule -> variables .)
    LBRACKET        reduce using rule 6 (father_rule -> variables .)
    KW_FOR          reduce using rule 6 (father_rule -> variables .)
    KW_IF           reduce using rule 6 (father_rule -> variables .)
    KW_ELSE         reduce using rule 6 (father_rule -> variables .)
    KW_WHILE        reduce using rule 6 (father_rule -> variables .)
    INTEGER         reduce using rule 6 (father_rule -> variables .)
    FLOAT           reduce using rule 6 (father_rule -> variables .)
    KW_CONST        reduce using rule 6 (father_rule -> variables .)
    QUOTE           reduce using rule 6 (father_rule -> variables .)
    $end            reduce using rule 6 (father_rule -> variables .)
    RBRACE          reduce using rule 6 (father_rule -> variables .)
    KW_RETURN       reduce using rule 6 (father_rule -> variables .)


state 7

    (7) father_rule -> control_str .

    KW_PRINT        reduce using rule 7 (father_rule -> control_str .)
    KW_LET          reduce using rule 7 (father_rule -> control_str .)
    KW_FN           reduce using rule 7 (father_rule -> control_str .)
    VARIABLE        reduce using rule 7 (father_rule -> control_str .)
    LPAREN          reduce using rule 7 (father_rule -> control_str .)
    LBRACKET        reduce using rule 7 (father_rule -> control_str .)
    KW_FOR          reduce using rule 7 (father_rule -> control_str .)
    KW_IF           reduce using rule 7 (father_rule -> control_str .)
    KW_ELSE         reduce using rule 7 (father_rule -> control_str .)
    KW_WHILE        reduce using rule 7 (father_rule -> control_str .)
    INTEGER         reduce using rule 7 (father_rule -> control_str .)
    FLOAT           reduce using rule 7 (father_rule -> control_str .)
    KW_CONST        reduce using rule 7 (father_rule -> control_str .)
    QUOTE           reduce using rule 7 (father_rule -> control_str .)
    $end            reduce using rule 7 (father_rule -> control_str .)
    RBRACE          reduce using rule 7 (father_rule -> control_str .)
    KW_RETURN       reduce using rule 7 (father_rule -> control_str .)


state 8

    (8) father_rule -> expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

    KW_PRINT        reduce using rule 8 (father_rule -> expression .)
    KW_LET          reduce using rule 8 (father_rule -> expression .)
    KW_FN           reduce using rule 8 (father_rule -> expression .)
    VARIABLE        reduce using rule 8 (father_rule -> expression .)
    LPAREN          reduce using rule 8 (father_rule -> expression .)
    LBRACKET        reduce using rule 8 (father_rule -> expression .)
    KW_FOR          reduce using rule 8 (father_rule -> expression .)
    KW_IF           reduce using rule 8 (father_rule -> expression .)
    KW_ELSE         reduce using rule 8 (father_rule -> expression .)
    KW_WHILE        reduce using rule 8 (father_rule -> expression .)
    INTEGER         reduce using rule 8 (father_rule -> expression .)
    FLOAT           reduce using rule 8 (father_rule -> expression .)
    KW_CONST        reduce using rule 8 (father_rule -> expression .)
    QUOTE           reduce using rule 8 (father_rule -> expression .)
    $end            reduce using rule 8 (father_rule -> expression .)
    RBRACE          reduce using rule 8 (father_rule -> expression .)
    KW_RETURN       reduce using rule 8 (father_rule -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45


state 9

    (9) father_rule -> void .

    KW_PRINT        reduce using rule 9 (father_rule -> void .)
    KW_LET          reduce using rule 9 (father_rule -> void .)
    KW_FN           reduce using rule 9 (father_rule -> void .)
    VARIABLE        reduce using rule 9 (father_rule -> void .)
    LPAREN          reduce using rule 9 (father_rule -> void .)
    LBRACKET        reduce using rule 9 (father_rule -> void .)
    KW_FOR          reduce using rule 9 (father_rule -> void .)
    KW_IF           reduce using rule 9 (father_rule -> void .)
    KW_ELSE         reduce using rule 9 (father_rule -> void .)
    KW_WHILE        reduce using rule 9 (father_rule -> void .)
    INTEGER         reduce using rule 9 (father_rule -> void .)
    FLOAT           reduce using rule 9 (father_rule -> void .)
    KW_CONST        reduce using rule 9 (father_rule -> void .)
    QUOTE           reduce using rule 9 (father_rule -> void .)
    $end            reduce using rule 9 (father_rule -> void .)
    RBRACE          reduce using rule 9 (father_rule -> void .)
    KW_RETURN       reduce using rule 9 (father_rule -> void .)


state 10

    (10) father_rule -> data_str .
    (68) initialization -> data_str . SEMI

    KW_PRINT        reduce using rule 10 (father_rule -> data_str .)
    KW_LET          reduce using rule 10 (father_rule -> data_str .)
    KW_FN           reduce using rule 10 (father_rule -> data_str .)
    VARIABLE        reduce using rule 10 (father_rule -> data_str .)
    LPAREN          reduce using rule 10 (father_rule -> data_str .)
    LBRACKET        reduce using rule 10 (father_rule -> data_str .)
    KW_FOR          reduce using rule 10 (father_rule -> data_str .)
    KW_IF           reduce using rule 10 (father_rule -> data_str .)
    KW_ELSE         reduce using rule 10 (father_rule -> data_str .)
    KW_WHILE        reduce using rule 10 (father_rule -> data_str .)
    INTEGER         reduce using rule 10 (father_rule -> data_str .)
    FLOAT           reduce using rule 10 (father_rule -> data_str .)
    KW_CONST        reduce using rule 10 (father_rule -> data_str .)
    QUOTE           reduce using rule 10 (father_rule -> data_str .)
    $end            reduce using rule 10 (father_rule -> data_str .)
    RBRACE          reduce using rule 10 (father_rule -> data_str .)
    KW_RETURN       reduce using rule 10 (father_rule -> data_str .)
    SEMI            shift and go to state 46


state 11

    (11) father_rule -> array .
    (93) data_str -> array .

  ! reduce/reduce conflict for KW_PRINT resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_LET resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_FN resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for LPAREN resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_FOR resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_IF resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_ELSE resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_WHILE resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for INTEGER resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for FLOAT resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_CONST resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for QUOTE resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for $end resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for RBRACE resolved using rule 11 (father_rule -> array .)
  ! reduce/reduce conflict for KW_RETURN resolved using rule 11 (father_rule -> array .)
    KW_PRINT        reduce using rule 11 (father_rule -> array .)
    KW_LET          reduce using rule 11 (father_rule -> array .)
    KW_FN           reduce using rule 11 (father_rule -> array .)
    VARIABLE        reduce using rule 11 (father_rule -> array .)
    LPAREN          reduce using rule 11 (father_rule -> array .)
    LBRACKET        reduce using rule 11 (father_rule -> array .)
    KW_FOR          reduce using rule 11 (father_rule -> array .)
    KW_IF           reduce using rule 11 (father_rule -> array .)
    KW_ELSE         reduce using rule 11 (father_rule -> array .)
    KW_WHILE        reduce using rule 11 (father_rule -> array .)
    INTEGER         reduce using rule 11 (father_rule -> array .)
    FLOAT           reduce using rule 11 (father_rule -> array .)
    KW_CONST        reduce using rule 11 (father_rule -> array .)
    QUOTE           reduce using rule 11 (father_rule -> array .)
    $end            reduce using rule 11 (father_rule -> array .)
    RBRACE          reduce using rule 11 (father_rule -> array .)
    KW_RETURN       reduce using rule 11 (father_rule -> array .)
    SEMI            reduce using rule 93 (data_str -> array .)

  ! KW_PRINT        [ reduce using rule 93 (data_str -> array .) ]
  ! KW_LET          [ reduce using rule 93 (data_str -> array .) ]
  ! KW_FN           [ reduce using rule 93 (data_str -> array .) ]
  ! VARIABLE        [ reduce using rule 93 (data_str -> array .) ]
  ! LPAREN          [ reduce using rule 93 (data_str -> array .) ]
  ! LBRACKET        [ reduce using rule 93 (data_str -> array .) ]
  ! KW_FOR          [ reduce using rule 93 (data_str -> array .) ]
  ! KW_IF           [ reduce using rule 93 (data_str -> array .) ]
  ! KW_ELSE         [ reduce using rule 93 (data_str -> array .) ]
  ! KW_WHILE        [ reduce using rule 93 (data_str -> array .) ]
  ! INTEGER         [ reduce using rule 93 (data_str -> array .) ]
  ! FLOAT           [ reduce using rule 93 (data_str -> array .) ]
  ! KW_CONST        [ reduce using rule 93 (data_str -> array .) ]
  ! QUOTE           [ reduce using rule 93 (data_str -> array .) ]
  ! $end            [ reduce using rule 93 (data_str -> array .) ]
  ! RBRACE          [ reduce using rule 93 (data_str -> array .) ]
  ! KW_RETURN       [ reduce using rule 93 (data_str -> array .) ]


state 12

    (12) father_rule -> linkedlist_methods .

    KW_PRINT        reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_LET          reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_FN           reduce using rule 12 (father_rule -> linkedlist_methods .)
    VARIABLE        reduce using rule 12 (father_rule -> linkedlist_methods .)
    LPAREN          reduce using rule 12 (father_rule -> linkedlist_methods .)
    LBRACKET        reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_FOR          reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_IF           reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_ELSE         reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_WHILE        reduce using rule 12 (father_rule -> linkedlist_methods .)
    INTEGER         reduce using rule 12 (father_rule -> linkedlist_methods .)
    FLOAT           reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_CONST        reduce using rule 12 (father_rule -> linkedlist_methods .)
    QUOTE           reduce using rule 12 (father_rule -> linkedlist_methods .)
    $end            reduce using rule 12 (father_rule -> linkedlist_methods .)
    RBRACE          reduce using rule 12 (father_rule -> linkedlist_methods .)
    KW_RETURN       reduce using rule 12 (father_rule -> linkedlist_methods .)


state 13

    (13) father_rule -> hashmap_methods .

    KW_PRINT        reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_LET          reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_FN           reduce using rule 13 (father_rule -> hashmap_methods .)
    VARIABLE        reduce using rule 13 (father_rule -> hashmap_methods .)
    LPAREN          reduce using rule 13 (father_rule -> hashmap_methods .)
    LBRACKET        reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_FOR          reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_IF           reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_ELSE         reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_WHILE        reduce using rule 13 (father_rule -> hashmap_methods .)
    INTEGER         reduce using rule 13 (father_rule -> hashmap_methods .)
    FLOAT           reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_CONST        reduce using rule 13 (father_rule -> hashmap_methods .)
    QUOTE           reduce using rule 13 (father_rule -> hashmap_methods .)
    $end            reduce using rule 13 (father_rule -> hashmap_methods .)
    RBRACE          reduce using rule 13 (father_rule -> hashmap_methods .)
    KW_RETURN       reduce using rule 13 (father_rule -> hashmap_methods .)


state 14

    (14) father_rule -> initialization .

    KW_PRINT        reduce using rule 14 (father_rule -> initialization .)
    KW_LET          reduce using rule 14 (father_rule -> initialization .)
    KW_FN           reduce using rule 14 (father_rule -> initialization .)
    VARIABLE        reduce using rule 14 (father_rule -> initialization .)
    LPAREN          reduce using rule 14 (father_rule -> initialization .)
    LBRACKET        reduce using rule 14 (father_rule -> initialization .)
    KW_FOR          reduce using rule 14 (father_rule -> initialization .)
    KW_IF           reduce using rule 14 (father_rule -> initialization .)
    KW_ELSE         reduce using rule 14 (father_rule -> initialization .)
    KW_WHILE        reduce using rule 14 (father_rule -> initialization .)
    INTEGER         reduce using rule 14 (father_rule -> initialization .)
    FLOAT           reduce using rule 14 (father_rule -> initialization .)
    KW_CONST        reduce using rule 14 (father_rule -> initialization .)
    QUOTE           reduce using rule 14 (father_rule -> initialization .)
    $end            reduce using rule 14 (father_rule -> initialization .)
    RBRACE          reduce using rule 14 (father_rule -> initialization .)
    KW_RETURN       reduce using rule 14 (father_rule -> initialization .)


state 15

    (58) print -> KW_PRINT . LPAREN CADENA RPAREN SEMI

    LPAREN          shift and go to state 47


state 16

    (19) expression -> LPAREN . expression RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    VARIABLE        shift and go to state 49

    expression                     shift and go to state 48
    number                         shift and go to state 26

state 17

    (59) dvariable -> KW_LET . VARIABLE SEMI
    (60) array -> KW_LET . VARIABLE EQUALS LBRACKET mdata RBRACKET
    (96) hashmap -> KW_LET . VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> KW_LET . KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET . VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> KW_LET . KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> KW_LET . VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> KW_LET . KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> KW_LET . VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> KW_LET . KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> KW_LET . VARIABLE EQUALS data
    (70) let_initialization -> KW_LET . VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> KW_LET . KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> KW_LET . KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> KW_LET . VARIABLE EQUALS expression_var
    (74) let_initialization -> KW_LET . VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> KW_LET . KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> KW_LET . KW_MUT VARIABLE COLON data_type EQUALS expression_var

    VARIABLE        shift and go to state 50
    KW_MUT          shift and go to state 51


state 18

    (62) variables -> VARIABLE .
    (63) variables -> VARIABLE . COMMA variables
    (109) linkedlist_methods -> VARIABLE . linkedlist_push
    (110) linkedlist_methods -> VARIABLE . linkedlist_remove
    (100) hashmap_methods -> VARIABLE . hashmap_insert
    (101) hashmap_methods -> VARIABLE . hashmap_remove
    (23) number -> VARIABLE .
    (111) linkedlist_push -> . DOT KW_PUSH_BACK LPAREN data RPAREN SEMI
    (112) linkedlist_remove -> . DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI
    (102) hashmap_insert -> . DOT KW_INSERT LPAREN mdata RPAREN SEMI
    (103) hashmap_remove -> . DOT KW_REMOVE LPAREN AND data RPAREN SEMI

  ! reduce/reduce conflict for KW_PRINT resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_LET resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_FN resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_FOR resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_IF resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_ELSE resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_WHILE resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for INTEGER resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for FLOAT resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_CONST resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for QUOTE resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for $end resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 23 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_RETURN resolved using rule 23 (number -> VARIABLE .)
    COMMA           shift and go to state 52
    PLUS            reduce using rule 23 (number -> VARIABLE .)
    MINUS           reduce using rule 23 (number -> VARIABLE .)
    TIMES           reduce using rule 23 (number -> VARIABLE .)
    DIVIDE          reduce using rule 23 (number -> VARIABLE .)
    KW_PRINT        reduce using rule 23 (number -> VARIABLE .)
    KW_LET          reduce using rule 23 (number -> VARIABLE .)
    KW_FN           reduce using rule 23 (number -> VARIABLE .)
    VARIABLE        reduce using rule 23 (number -> VARIABLE .)
    LPAREN          reduce using rule 23 (number -> VARIABLE .)
    LBRACKET        reduce using rule 23 (number -> VARIABLE .)
    KW_FOR          reduce using rule 23 (number -> VARIABLE .)
    KW_IF           reduce using rule 23 (number -> VARIABLE .)
    KW_ELSE         reduce using rule 23 (number -> VARIABLE .)
    KW_WHILE        reduce using rule 23 (number -> VARIABLE .)
    INTEGER         reduce using rule 23 (number -> VARIABLE .)
    FLOAT           reduce using rule 23 (number -> VARIABLE .)
    KW_CONST        reduce using rule 23 (number -> VARIABLE .)
    QUOTE           reduce using rule 23 (number -> VARIABLE .)
    $end            reduce using rule 23 (number -> VARIABLE .)
    RBRACE          reduce using rule 23 (number -> VARIABLE .)
    KW_RETURN       reduce using rule 23 (number -> VARIABLE .)
    DOT             shift and go to state 57

  ! KW_PRINT        [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_LET          [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_FN           [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! VARIABLE        [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! LPAREN          [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! LBRACKET        [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_FOR          [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_IF           [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_ELSE         [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_WHILE        [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! INTEGER         [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! FLOAT           [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_CONST        [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! QUOTE           [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! $end            [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 62 (variables -> VARIABLE .) ]
  ! KW_RETURN       [ reduce using rule 62 (variables -> VARIABLE .) ]

    linkedlist_push                shift and go to state 53
    linkedlist_remove              shift and go to state 54
    hashmap_insert                 shift and go to state 55
    hashmap_remove                 shift and go to state 56

state 19

    (80) function -> KW_FN . VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> KW_FN . VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE

    VARIABLE        shift and go to state 58


state 20

    (81) control_str -> for_str .

    KW_PRINT        reduce using rule 81 (control_str -> for_str .)
    KW_LET          reduce using rule 81 (control_str -> for_str .)
    KW_FN           reduce using rule 81 (control_str -> for_str .)
    VARIABLE        reduce using rule 81 (control_str -> for_str .)
    LPAREN          reduce using rule 81 (control_str -> for_str .)
    LBRACKET        reduce using rule 81 (control_str -> for_str .)
    KW_FOR          reduce using rule 81 (control_str -> for_str .)
    KW_IF           reduce using rule 81 (control_str -> for_str .)
    KW_ELSE         reduce using rule 81 (control_str -> for_str .)
    KW_WHILE        reduce using rule 81 (control_str -> for_str .)
    INTEGER         reduce using rule 81 (control_str -> for_str .)
    FLOAT           reduce using rule 81 (control_str -> for_str .)
    KW_CONST        reduce using rule 81 (control_str -> for_str .)
    QUOTE           reduce using rule 81 (control_str -> for_str .)
    $end            reduce using rule 81 (control_str -> for_str .)
    RBRACE          reduce using rule 81 (control_str -> for_str .)
    KW_RETURN       reduce using rule 81 (control_str -> for_str .)


state 21

    (82) control_str -> for_str_tagged .

    KW_PRINT        reduce using rule 82 (control_str -> for_str_tagged .)
    KW_LET          reduce using rule 82 (control_str -> for_str_tagged .)
    KW_FN           reduce using rule 82 (control_str -> for_str_tagged .)
    VARIABLE        reduce using rule 82 (control_str -> for_str_tagged .)
    LPAREN          reduce using rule 82 (control_str -> for_str_tagged .)
    LBRACKET        reduce using rule 82 (control_str -> for_str_tagged .)
    KW_FOR          reduce using rule 82 (control_str -> for_str_tagged .)
    KW_IF           reduce using rule 82 (control_str -> for_str_tagged .)
    KW_ELSE         reduce using rule 82 (control_str -> for_str_tagged .)
    KW_WHILE        reduce using rule 82 (control_str -> for_str_tagged .)
    INTEGER         reduce using rule 82 (control_str -> for_str_tagged .)
    FLOAT           reduce using rule 82 (control_str -> for_str_tagged .)
    KW_CONST        reduce using rule 82 (control_str -> for_str_tagged .)
    QUOTE           reduce using rule 82 (control_str -> for_str_tagged .)
    $end            reduce using rule 82 (control_str -> for_str_tagged .)
    RBRACE          reduce using rule 82 (control_str -> for_str_tagged .)
    KW_RETURN       reduce using rule 82 (control_str -> for_str_tagged .)


state 22

    (83) control_str -> if .

    KW_PRINT        reduce using rule 83 (control_str -> if .)
    KW_LET          reduce using rule 83 (control_str -> if .)
    KW_FN           reduce using rule 83 (control_str -> if .)
    VARIABLE        reduce using rule 83 (control_str -> if .)
    LPAREN          reduce using rule 83 (control_str -> if .)
    LBRACKET        reduce using rule 83 (control_str -> if .)
    KW_FOR          reduce using rule 83 (control_str -> if .)
    KW_IF           reduce using rule 83 (control_str -> if .)
    KW_ELSE         reduce using rule 83 (control_str -> if .)
    KW_WHILE        reduce using rule 83 (control_str -> if .)
    INTEGER         reduce using rule 83 (control_str -> if .)
    FLOAT           reduce using rule 83 (control_str -> if .)
    KW_CONST        reduce using rule 83 (control_str -> if .)
    QUOTE           reduce using rule 83 (control_str -> if .)
    $end            reduce using rule 83 (control_str -> if .)
    RBRACE          reduce using rule 83 (control_str -> if .)
    KW_RETURN       reduce using rule 83 (control_str -> if .)


state 23

    (84) control_str -> else .

    KW_PRINT        reduce using rule 84 (control_str -> else .)
    KW_LET          reduce using rule 84 (control_str -> else .)
    KW_FN           reduce using rule 84 (control_str -> else .)
    VARIABLE        reduce using rule 84 (control_str -> else .)
    LPAREN          reduce using rule 84 (control_str -> else .)
    LBRACKET        reduce using rule 84 (control_str -> else .)
    KW_FOR          reduce using rule 84 (control_str -> else .)
    KW_IF           reduce using rule 84 (control_str -> else .)
    KW_ELSE         reduce using rule 84 (control_str -> else .)
    KW_WHILE        reduce using rule 84 (control_str -> else .)
    INTEGER         reduce using rule 84 (control_str -> else .)
    FLOAT           reduce using rule 84 (control_str -> else .)
    KW_CONST        reduce using rule 84 (control_str -> else .)
    QUOTE           reduce using rule 84 (control_str -> else .)
    $end            reduce using rule 84 (control_str -> else .)
    RBRACE          reduce using rule 84 (control_str -> else .)
    KW_RETURN       reduce using rule 84 (control_str -> else .)


state 24

    (85) control_str -> else_if .

    KW_PRINT        reduce using rule 85 (control_str -> else_if .)
    KW_LET          reduce using rule 85 (control_str -> else_if .)
    KW_FN           reduce using rule 85 (control_str -> else_if .)
    VARIABLE        reduce using rule 85 (control_str -> else_if .)
    LPAREN          reduce using rule 85 (control_str -> else_if .)
    LBRACKET        reduce using rule 85 (control_str -> else_if .)
    KW_FOR          reduce using rule 85 (control_str -> else_if .)
    KW_IF           reduce using rule 85 (control_str -> else_if .)
    KW_ELSE         reduce using rule 85 (control_str -> else_if .)
    KW_WHILE        reduce using rule 85 (control_str -> else_if .)
    INTEGER         reduce using rule 85 (control_str -> else_if .)
    FLOAT           reduce using rule 85 (control_str -> else_if .)
    KW_CONST        reduce using rule 85 (control_str -> else_if .)
    QUOTE           reduce using rule 85 (control_str -> else_if .)
    $end            reduce using rule 85 (control_str -> else_if .)
    RBRACE          reduce using rule 85 (control_str -> else_if .)
    KW_RETURN       reduce using rule 85 (control_str -> else_if .)


state 25

    (86) control_str -> while .

    KW_PRINT        reduce using rule 86 (control_str -> while .)
    KW_LET          reduce using rule 86 (control_str -> while .)
    KW_FN           reduce using rule 86 (control_str -> while .)
    VARIABLE        reduce using rule 86 (control_str -> while .)
    LPAREN          reduce using rule 86 (control_str -> while .)
    LBRACKET        reduce using rule 86 (control_str -> while .)
    KW_FOR          reduce using rule 86 (control_str -> while .)
    KW_IF           reduce using rule 86 (control_str -> while .)
    KW_ELSE         reduce using rule 86 (control_str -> while .)
    KW_WHILE        reduce using rule 86 (control_str -> while .)
    INTEGER         reduce using rule 86 (control_str -> while .)
    FLOAT           reduce using rule 86 (control_str -> while .)
    KW_CONST        reduce using rule 86 (control_str -> while .)
    QUOTE           reduce using rule 86 (control_str -> while .)
    $end            reduce using rule 86 (control_str -> while .)
    RBRACE          reduce using rule 86 (control_str -> while .)
    KW_RETURN       reduce using rule 86 (control_str -> while .)


state 26

    (20) expression -> number .

    PLUS            reduce using rule 20 (expression -> number .)
    MINUS           reduce using rule 20 (expression -> number .)
    TIMES           reduce using rule 20 (expression -> number .)
    DIVIDE          reduce using rule 20 (expression -> number .)
    KW_PRINT        reduce using rule 20 (expression -> number .)
    KW_LET          reduce using rule 20 (expression -> number .)
    KW_FN           reduce using rule 20 (expression -> number .)
    VARIABLE        reduce using rule 20 (expression -> number .)
    LPAREN          reduce using rule 20 (expression -> number .)
    LBRACKET        reduce using rule 20 (expression -> number .)
    KW_FOR          reduce using rule 20 (expression -> number .)
    KW_IF           reduce using rule 20 (expression -> number .)
    KW_ELSE         reduce using rule 20 (expression -> number .)
    KW_WHILE        reduce using rule 20 (expression -> number .)
    INTEGER         reduce using rule 20 (expression -> number .)
    FLOAT           reduce using rule 20 (expression -> number .)
    KW_CONST        reduce using rule 20 (expression -> number .)
    QUOTE           reduce using rule 20 (expression -> number .)
    $end            reduce using rule 20 (expression -> number .)
    RBRACE          reduce using rule 20 (expression -> number .)
    KW_RETURN       reduce using rule 20 (expression -> number .)
    RPAREN          reduce using rule 20 (expression -> number .)
    SEMI            reduce using rule 20 (expression -> number .)


state 27

    (94) data_str -> hashmap .

    SEMI            reduce using rule 94 (data_str -> hashmap .)
    KW_PRINT        reduce using rule 94 (data_str -> hashmap .)
    KW_LET          reduce using rule 94 (data_str -> hashmap .)
    KW_FN           reduce using rule 94 (data_str -> hashmap .)
    VARIABLE        reduce using rule 94 (data_str -> hashmap .)
    LPAREN          reduce using rule 94 (data_str -> hashmap .)
    LBRACKET        reduce using rule 94 (data_str -> hashmap .)
    KW_FOR          reduce using rule 94 (data_str -> hashmap .)
    KW_IF           reduce using rule 94 (data_str -> hashmap .)
    KW_ELSE         reduce using rule 94 (data_str -> hashmap .)
    KW_WHILE        reduce using rule 94 (data_str -> hashmap .)
    INTEGER         reduce using rule 94 (data_str -> hashmap .)
    FLOAT           reduce using rule 94 (data_str -> hashmap .)
    KW_CONST        reduce using rule 94 (data_str -> hashmap .)
    QUOTE           reduce using rule 94 (data_str -> hashmap .)
    $end            reduce using rule 94 (data_str -> hashmap .)
    RBRACE          reduce using rule 94 (data_str -> hashmap .)
    KW_RETURN       reduce using rule 94 (data_str -> hashmap .)


state 28

    (95) data_str -> linkedlist .

    SEMI            reduce using rule 95 (data_str -> linkedlist .)
    KW_PRINT        reduce using rule 95 (data_str -> linkedlist .)
    KW_LET          reduce using rule 95 (data_str -> linkedlist .)
    KW_FN           reduce using rule 95 (data_str -> linkedlist .)
    VARIABLE        reduce using rule 95 (data_str -> linkedlist .)
    LPAREN          reduce using rule 95 (data_str -> linkedlist .)
    LBRACKET        reduce using rule 95 (data_str -> linkedlist .)
    KW_FOR          reduce using rule 95 (data_str -> linkedlist .)
    KW_IF           reduce using rule 95 (data_str -> linkedlist .)
    KW_ELSE         reduce using rule 95 (data_str -> linkedlist .)
    KW_WHILE        reduce using rule 95 (data_str -> linkedlist .)
    INTEGER         reduce using rule 95 (data_str -> linkedlist .)
    FLOAT           reduce using rule 95 (data_str -> linkedlist .)
    KW_CONST        reduce using rule 95 (data_str -> linkedlist .)
    QUOTE           reduce using rule 95 (data_str -> linkedlist .)
    $end            reduce using rule 95 (data_str -> linkedlist .)
    RBRACE          reduce using rule 95 (data_str -> linkedlist .)
    KW_RETURN       reduce using rule 95 (data_str -> linkedlist .)


state 29

    (61) array -> LBRACKET . mdata RBRACKET
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    mdata                          shift and go to state 59
    data                           shift and go to state 60
    tuple                          shift and go to state 67

state 30

    (66) initialization -> let_initialization . SEMI

    SEMI            shift and go to state 69


state 31

    (67) initialization -> const_initialization . SEMI

    SEMI            shift and go to state 70


state 32

    (87) for_str -> KW_FOR . VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> KW_FOR . VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE

    VARIABLE        shift and go to state 71


state 33

    (89) for_str_tagged -> label . COLON for_str

    COLON           shift and go to state 72


state 34

    (113) if -> KW_IF . conditional LBRACE main_rule RBRACE
    (53) conditional -> . VARIABLE comparator data
    (54) conditional -> . and comparator data
    (52) and -> . VARIABLE LAND VARIABLE

    VARIABLE        shift and go to state 74

    conditional                    shift and go to state 73
    and                            shift and go to state 75

state 35

    (114) else -> KW_ELSE . LBRACE main_rule RBRACE
    (115) else_if -> KW_ELSE . KW_IF conditional LBRACE main_rule RBRACE

    LBRACE          shift and go to state 76
    KW_IF           shift and go to state 77


state 36

    (64) while -> KW_WHILE . LPAREN VARIABLE

    LPAREN          shift and go to state 78


state 37

    (21) number -> INTEGER .

    PLUS            reduce using rule 21 (number -> INTEGER .)
    MINUS           reduce using rule 21 (number -> INTEGER .)
    TIMES           reduce using rule 21 (number -> INTEGER .)
    DIVIDE          reduce using rule 21 (number -> INTEGER .)
    KW_PRINT        reduce using rule 21 (number -> INTEGER .)
    KW_LET          reduce using rule 21 (number -> INTEGER .)
    KW_FN           reduce using rule 21 (number -> INTEGER .)
    VARIABLE        reduce using rule 21 (number -> INTEGER .)
    LPAREN          reduce using rule 21 (number -> INTEGER .)
    LBRACKET        reduce using rule 21 (number -> INTEGER .)
    KW_FOR          reduce using rule 21 (number -> INTEGER .)
    KW_IF           reduce using rule 21 (number -> INTEGER .)
    KW_ELSE         reduce using rule 21 (number -> INTEGER .)
    KW_WHILE        reduce using rule 21 (number -> INTEGER .)
    INTEGER         reduce using rule 21 (number -> INTEGER .)
    FLOAT           reduce using rule 21 (number -> INTEGER .)
    KW_CONST        reduce using rule 21 (number -> INTEGER .)
    QUOTE           reduce using rule 21 (number -> INTEGER .)
    $end            reduce using rule 21 (number -> INTEGER .)
    RBRACE          reduce using rule 21 (number -> INTEGER .)
    KW_RETURN       reduce using rule 21 (number -> INTEGER .)
    RPAREN          reduce using rule 21 (number -> INTEGER .)
    SEMI            reduce using rule 21 (number -> INTEGER .)


state 38

    (22) number -> FLOAT .

    PLUS            reduce using rule 22 (number -> FLOAT .)
    MINUS           reduce using rule 22 (number -> FLOAT .)
    TIMES           reduce using rule 22 (number -> FLOAT .)
    DIVIDE          reduce using rule 22 (number -> FLOAT .)
    KW_PRINT        reduce using rule 22 (number -> FLOAT .)
    KW_LET          reduce using rule 22 (number -> FLOAT .)
    KW_FN           reduce using rule 22 (number -> FLOAT .)
    VARIABLE        reduce using rule 22 (number -> FLOAT .)
    LPAREN          reduce using rule 22 (number -> FLOAT .)
    LBRACKET        reduce using rule 22 (number -> FLOAT .)
    KW_FOR          reduce using rule 22 (number -> FLOAT .)
    KW_IF           reduce using rule 22 (number -> FLOAT .)
    KW_ELSE         reduce using rule 22 (number -> FLOAT .)
    KW_WHILE        reduce using rule 22 (number -> FLOAT .)
    INTEGER         reduce using rule 22 (number -> FLOAT .)
    FLOAT           reduce using rule 22 (number -> FLOAT .)
    KW_CONST        reduce using rule 22 (number -> FLOAT .)
    QUOTE           reduce using rule 22 (number -> FLOAT .)
    $end            reduce using rule 22 (number -> FLOAT .)
    RBRACE          reduce using rule 22 (number -> FLOAT .)
    KW_RETURN       reduce using rule 22 (number -> FLOAT .)
    RPAREN          reduce using rule 22 (number -> FLOAT .)
    SEMI            reduce using rule 22 (number -> FLOAT .)


state 39

    (77) const_initialization -> KW_CONST . VARIABLE COLON data_type EQUALS data

    VARIABLE        shift and go to state 79


state 40

    (92) label -> QUOTE . VARIABLE

    VARIABLE        shift and go to state 80


state 41

    (2) main_rule -> father_rule main_rule .

    $end            reduce using rule 2 (main_rule -> father_rule main_rule .)
    RBRACE          reduce using rule 2 (main_rule -> father_rule main_rule .)
    KW_RETURN       reduce using rule 2 (main_rule -> father_rule main_rule .)


state 42

    (15) expression -> expression PLUS . expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    VARIABLE        shift and go to state 49

    expression                     shift and go to state 81
    number                         shift and go to state 26

state 43

    (16) expression -> expression MINUS . expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    VARIABLE        shift and go to state 49

    expression                     shift and go to state 82
    number                         shift and go to state 26

state 44

    (17) expression -> expression TIMES . expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    VARIABLE        shift and go to state 49

    expression                     shift and go to state 83
    number                         shift and go to state 26

state 45

    (18) expression -> expression DIVIDE . expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    VARIABLE        shift and go to state 49

    expression                     shift and go to state 84
    number                         shift and go to state 26

state 46

    (68) initialization -> data_str SEMI .

    KW_PRINT        reduce using rule 68 (initialization -> data_str SEMI .)
    KW_LET          reduce using rule 68 (initialization -> data_str SEMI .)
    KW_FN           reduce using rule 68 (initialization -> data_str SEMI .)
    VARIABLE        reduce using rule 68 (initialization -> data_str SEMI .)
    LPAREN          reduce using rule 68 (initialization -> data_str SEMI .)
    LBRACKET        reduce using rule 68 (initialization -> data_str SEMI .)
    KW_FOR          reduce using rule 68 (initialization -> data_str SEMI .)
    KW_IF           reduce using rule 68 (initialization -> data_str SEMI .)
    KW_ELSE         reduce using rule 68 (initialization -> data_str SEMI .)
    KW_WHILE        reduce using rule 68 (initialization -> data_str SEMI .)
    INTEGER         reduce using rule 68 (initialization -> data_str SEMI .)
    FLOAT           reduce using rule 68 (initialization -> data_str SEMI .)
    KW_CONST        reduce using rule 68 (initialization -> data_str SEMI .)
    QUOTE           reduce using rule 68 (initialization -> data_str SEMI .)
    $end            reduce using rule 68 (initialization -> data_str SEMI .)
    RBRACE          reduce using rule 68 (initialization -> data_str SEMI .)
    KW_RETURN       reduce using rule 68 (initialization -> data_str SEMI .)


state 47

    (58) print -> KW_PRINT LPAREN . CADENA RPAREN SEMI

    CADENA          shift and go to state 85


state 48

    (19) expression -> LPAREN expression . RPAREN
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45


state 49

    (23) number -> VARIABLE .

    RPAREN          reduce using rule 23 (number -> VARIABLE .)
    PLUS            reduce using rule 23 (number -> VARIABLE .)
    MINUS           reduce using rule 23 (number -> VARIABLE .)
    TIMES           reduce using rule 23 (number -> VARIABLE .)
    DIVIDE          reduce using rule 23 (number -> VARIABLE .)
    KW_PRINT        reduce using rule 23 (number -> VARIABLE .)
    KW_LET          reduce using rule 23 (number -> VARIABLE .)
    KW_FN           reduce using rule 23 (number -> VARIABLE .)
    VARIABLE        reduce using rule 23 (number -> VARIABLE .)
    LPAREN          reduce using rule 23 (number -> VARIABLE .)
    LBRACKET        reduce using rule 23 (number -> VARIABLE .)
    KW_FOR          reduce using rule 23 (number -> VARIABLE .)
    KW_IF           reduce using rule 23 (number -> VARIABLE .)
    KW_ELSE         reduce using rule 23 (number -> VARIABLE .)
    KW_WHILE        reduce using rule 23 (number -> VARIABLE .)
    INTEGER         reduce using rule 23 (number -> VARIABLE .)
    FLOAT           reduce using rule 23 (number -> VARIABLE .)
    KW_CONST        reduce using rule 23 (number -> VARIABLE .)
    QUOTE           reduce using rule 23 (number -> VARIABLE .)
    $end            reduce using rule 23 (number -> VARIABLE .)
    RBRACE          reduce using rule 23 (number -> VARIABLE .)
    KW_RETURN       reduce using rule 23 (number -> VARIABLE .)
    SEMI            reduce using rule 23 (number -> VARIABLE .)


state 50

    (59) dvariable -> KW_LET VARIABLE . SEMI
    (60) array -> KW_LET VARIABLE . EQUALS LBRACKET mdata RBRACKET
    (96) hashmap -> KW_LET VARIABLE . EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET VARIABLE . EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> KW_LET VARIABLE . COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> KW_LET VARIABLE . EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> KW_LET VARIABLE . EQUALS data
    (70) let_initialization -> KW_LET VARIABLE . COLON data_type EQUALS data
    (73) let_initialization -> KW_LET VARIABLE . EQUALS expression_var
    (74) let_initialization -> KW_LET VARIABLE . COLON data_type EQUALS expression_var

    SEMI            shift and go to state 87
    EQUALS          shift and go to state 88
    COLON           shift and go to state 89


state 51

    (97) hashmap -> KW_LET KW_MUT . VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT . VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (106) linkedlist -> KW_LET KW_MUT . VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (108) linkedlist -> KW_LET KW_MUT . VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (71) let_initialization -> KW_LET KW_MUT . VARIABLE EQUALS data
    (72) let_initialization -> KW_LET KW_MUT . VARIABLE COLON data_type EQUALS data
    (75) let_initialization -> KW_LET KW_MUT . VARIABLE EQUALS expression_var
    (76) let_initialization -> KW_LET KW_MUT . VARIABLE COLON data_type EQUALS expression_var

    VARIABLE        shift and go to state 90


state 52

    (63) variables -> VARIABLE COMMA . variables
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 91

    variables                      shift and go to state 92

state 53

    (109) linkedlist_methods -> VARIABLE linkedlist_push .

    KW_PRINT        reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_LET          reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_FN           reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    VARIABLE        reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    LPAREN          reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    LBRACKET        reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_FOR          reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_IF           reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_ELSE         reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_WHILE        reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    INTEGER         reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    FLOAT           reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_CONST        reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    QUOTE           reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    $end            reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    RBRACE          reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)
    KW_RETURN       reduce using rule 109 (linkedlist_methods -> VARIABLE linkedlist_push .)


state 54

    (110) linkedlist_methods -> VARIABLE linkedlist_remove .

    KW_PRINT        reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_LET          reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_FN           reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    VARIABLE        reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    LPAREN          reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    LBRACKET        reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_FOR          reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_IF           reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_ELSE         reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_WHILE        reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    INTEGER         reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    FLOAT           reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_CONST        reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    QUOTE           reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    $end            reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    RBRACE          reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)
    KW_RETURN       reduce using rule 110 (linkedlist_methods -> VARIABLE linkedlist_remove .)


state 55

    (100) hashmap_methods -> VARIABLE hashmap_insert .

    KW_PRINT        reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_LET          reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_FN           reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    VARIABLE        reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    LPAREN          reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    LBRACKET        reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_FOR          reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_IF           reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_ELSE         reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_WHILE        reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    INTEGER         reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    FLOAT           reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_CONST        reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    QUOTE           reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    $end            reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    RBRACE          reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)
    KW_RETURN       reduce using rule 100 (hashmap_methods -> VARIABLE hashmap_insert .)


state 56

    (101) hashmap_methods -> VARIABLE hashmap_remove .

    KW_PRINT        reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_LET          reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_FN           reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    VARIABLE        reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    LPAREN          reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    LBRACKET        reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_FOR          reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_IF           reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_ELSE         reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_WHILE        reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    INTEGER         reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    FLOAT           reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_CONST        reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    QUOTE           reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    $end            reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    RBRACE          reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)
    KW_RETURN       reduce using rule 101 (hashmap_methods -> VARIABLE hashmap_remove .)


state 57

    (111) linkedlist_push -> DOT . KW_PUSH_BACK LPAREN data RPAREN SEMI
    (112) linkedlist_remove -> DOT . KW_REMOVE LPAREN INTEGER RPAREN SEMI
    (102) hashmap_insert -> DOT . KW_INSERT LPAREN mdata RPAREN SEMI
    (103) hashmap_remove -> DOT . KW_REMOVE LPAREN AND data RPAREN SEMI

    KW_PUSH_BACK    shift and go to state 93
    KW_REMOVE       shift and go to state 94
    KW_INSERT       shift and go to state 95


state 58

    (80) function -> KW_FN VARIABLE . LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> KW_FN VARIABLE . LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE

    LPAREN          shift and go to state 96


state 59

    (61) array -> LBRACKET mdata . RBRACKET

    RBRACKET        shift and go to state 97


state 60

    (56) mdata -> data .
    (57) mdata -> data . COMMA mdata

    RBRACKET        reduce using rule 56 (mdata -> data .)
    RPAREN          reduce using rule 56 (mdata -> data .)
    COMMA           shift and go to state 98


state 61

    (38) data -> CADENA .

    COMMA           reduce using rule 38 (data -> CADENA .)
    RBRACKET        reduce using rule 38 (data -> CADENA .)
    RPAREN          reduce using rule 38 (data -> CADENA .)
    SEMI            reduce using rule 38 (data -> CADENA .)
    LBRACE          reduce using rule 38 (data -> CADENA .)


state 62

    (39) data -> INTEGER .

    COMMA           reduce using rule 39 (data -> INTEGER .)
    RBRACKET        reduce using rule 39 (data -> INTEGER .)
    RPAREN          reduce using rule 39 (data -> INTEGER .)
    LBRACE          reduce using rule 39 (data -> INTEGER .)
    SEMI            reduce using rule 39 (data -> INTEGER .)


state 63

    (40) data -> CHAR .

    COMMA           reduce using rule 40 (data -> CHAR .)
    RBRACKET        reduce using rule 40 (data -> CHAR .)
    RPAREN          reduce using rule 40 (data -> CHAR .)
    SEMI            reduce using rule 40 (data -> CHAR .)
    LBRACE          reduce using rule 40 (data -> CHAR .)


state 64

    (41) data -> FLOAT .

    COMMA           reduce using rule 41 (data -> FLOAT .)
    RBRACKET        reduce using rule 41 (data -> FLOAT .)
    RPAREN          reduce using rule 41 (data -> FLOAT .)
    LBRACE          reduce using rule 41 (data -> FLOAT .)
    SEMI            reduce using rule 41 (data -> FLOAT .)


state 65

    (42) data -> KW_FALSE .

    COMMA           reduce using rule 42 (data -> KW_FALSE .)
    RBRACKET        reduce using rule 42 (data -> KW_FALSE .)
    RPAREN          reduce using rule 42 (data -> KW_FALSE .)
    SEMI            reduce using rule 42 (data -> KW_FALSE .)
    LBRACE          reduce using rule 42 (data -> KW_FALSE .)


state 66

    (43) data -> KW_TRUE .

    COMMA           reduce using rule 43 (data -> KW_TRUE .)
    RBRACKET        reduce using rule 43 (data -> KW_TRUE .)
    RPAREN          reduce using rule 43 (data -> KW_TRUE .)
    SEMI            reduce using rule 43 (data -> KW_TRUE .)
    LBRACE          reduce using rule 43 (data -> KW_TRUE .)


state 67

    (44) data -> tuple .

    COMMA           reduce using rule 44 (data -> tuple .)
    RBRACKET        reduce using rule 44 (data -> tuple .)
    RPAREN          reduce using rule 44 (data -> tuple .)
    SEMI            reduce using rule 44 (data -> tuple .)
    LBRACE          reduce using rule 44 (data -> tuple .)


state 68

    (65) tuple -> LPAREN . mdata RPAREN
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    mdata                          shift and go to state 99
    data                           shift and go to state 60
    tuple                          shift and go to state 67

state 69

    (66) initialization -> let_initialization SEMI .

    KW_PRINT        reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_LET          reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_FN           reduce using rule 66 (initialization -> let_initialization SEMI .)
    VARIABLE        reduce using rule 66 (initialization -> let_initialization SEMI .)
    LPAREN          reduce using rule 66 (initialization -> let_initialization SEMI .)
    LBRACKET        reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_FOR          reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_IF           reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_ELSE         reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_WHILE        reduce using rule 66 (initialization -> let_initialization SEMI .)
    INTEGER         reduce using rule 66 (initialization -> let_initialization SEMI .)
    FLOAT           reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_CONST        reduce using rule 66 (initialization -> let_initialization SEMI .)
    QUOTE           reduce using rule 66 (initialization -> let_initialization SEMI .)
    $end            reduce using rule 66 (initialization -> let_initialization SEMI .)
    RBRACE          reduce using rule 66 (initialization -> let_initialization SEMI .)
    KW_RETURN       reduce using rule 66 (initialization -> let_initialization SEMI .)


state 70

    (67) initialization -> const_initialization SEMI .

    KW_PRINT        reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_LET          reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_FN           reduce using rule 67 (initialization -> const_initialization SEMI .)
    VARIABLE        reduce using rule 67 (initialization -> const_initialization SEMI .)
    LPAREN          reduce using rule 67 (initialization -> const_initialization SEMI .)
    LBRACKET        reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_FOR          reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_IF           reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_ELSE         reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_WHILE        reduce using rule 67 (initialization -> const_initialization SEMI .)
    INTEGER         reduce using rule 67 (initialization -> const_initialization SEMI .)
    FLOAT           reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_CONST        reduce using rule 67 (initialization -> const_initialization SEMI .)
    QUOTE           reduce using rule 67 (initialization -> const_initialization SEMI .)
    $end            reduce using rule 67 (initialization -> const_initialization SEMI .)
    RBRACE          reduce using rule 67 (initialization -> const_initialization SEMI .)
    KW_RETURN       reduce using rule 67 (initialization -> const_initialization SEMI .)


state 71

    (87) for_str -> KW_FOR VARIABLE . KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> KW_FOR VARIABLE . KW_IN VARIABLE LBRACE main_rule RBRACE

    KW_IN           shift and go to state 100


state 72

    (89) for_str_tagged -> label COLON . for_str
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE

    KW_FOR          shift and go to state 32

    for_str                        shift and go to state 101

state 73

    (113) if -> KW_IF conditional . LBRACE main_rule RBRACE

    LBRACE          shift and go to state 102


state 74

    (53) conditional -> VARIABLE . comparator data
    (52) and -> VARIABLE . LAND VARIABLE
    (45) comparator -> .
    (46) comparator -> . EQ
    (47) comparator -> . NE
    (48) comparator -> . GE
    (49) comparator -> . LE
    (50) comparator -> . GT
    (51) comparator -> . LT

    LAND            shift and go to state 104
    CADENA          reduce using rule 45 (comparator -> .)
    INTEGER         reduce using rule 45 (comparator -> .)
    CHAR            reduce using rule 45 (comparator -> .)
    FLOAT           reduce using rule 45 (comparator -> .)
    KW_FALSE        reduce using rule 45 (comparator -> .)
    KW_TRUE         reduce using rule 45 (comparator -> .)
    LPAREN          reduce using rule 45 (comparator -> .)
    EQ              shift and go to state 105
    NE              shift and go to state 106
    GE              shift and go to state 107
    LE              shift and go to state 108
    GT              shift and go to state 109
    LT              shift and go to state 110

    comparator                     shift and go to state 103

state 75

    (54) conditional -> and . comparator data
    (45) comparator -> .
    (46) comparator -> . EQ
    (47) comparator -> . NE
    (48) comparator -> . GE
    (49) comparator -> . LE
    (50) comparator -> . GT
    (51) comparator -> . LT

    CADENA          reduce using rule 45 (comparator -> .)
    INTEGER         reduce using rule 45 (comparator -> .)
    CHAR            reduce using rule 45 (comparator -> .)
    FLOAT           reduce using rule 45 (comparator -> .)
    KW_FALSE        reduce using rule 45 (comparator -> .)
    KW_TRUE         reduce using rule 45 (comparator -> .)
    LPAREN          reduce using rule 45 (comparator -> .)
    EQ              shift and go to state 105
    NE              shift and go to state 106
    GE              shift and go to state 107
    LE              shift and go to state 108
    GT              shift and go to state 109
    LT              shift and go to state 110

    comparator                     shift and go to state 111

state 76

    (114) else -> KW_ELSE LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 112
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 77

    (115) else_if -> KW_ELSE KW_IF . conditional LBRACE main_rule RBRACE
    (53) conditional -> . VARIABLE comparator data
    (54) conditional -> . and comparator data
    (52) and -> . VARIABLE LAND VARIABLE

    VARIABLE        shift and go to state 74

    conditional                    shift and go to state 113
    and                            shift and go to state 75

state 78

    (64) while -> KW_WHILE LPAREN . VARIABLE

    VARIABLE        shift and go to state 114


state 79

    (77) const_initialization -> KW_CONST VARIABLE . COLON data_type EQUALS data

    COLON           shift and go to state 115


state 80

    (92) label -> QUOTE VARIABLE .

    COLON           reduce using rule 92 (label -> QUOTE VARIABLE .)


state 81

    (15) expression -> expression PLUS expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 15 (expression -> expression PLUS expression .)
    KW_LET          reduce using rule 15 (expression -> expression PLUS expression .)
    KW_FN           reduce using rule 15 (expression -> expression PLUS expression .)
    VARIABLE        reduce using rule 15 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 15 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 15 (expression -> expression PLUS expression .)
    KW_FOR          reduce using rule 15 (expression -> expression PLUS expression .)
    KW_IF           reduce using rule 15 (expression -> expression PLUS expression .)
    KW_ELSE         reduce using rule 15 (expression -> expression PLUS expression .)
    KW_WHILE        reduce using rule 15 (expression -> expression PLUS expression .)
    INTEGER         reduce using rule 15 (expression -> expression PLUS expression .)
    FLOAT           reduce using rule 15 (expression -> expression PLUS expression .)
    KW_CONST        reduce using rule 15 (expression -> expression PLUS expression .)
    QUOTE           reduce using rule 15 (expression -> expression PLUS expression .)
    $end            reduce using rule 15 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 15 (expression -> expression PLUS expression .)
    KW_RETURN       reduce using rule 15 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 15 (expression -> expression PLUS expression .)
    SEMI            reduce using rule 15 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45

  ! PLUS            [ reduce using rule 15 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 15 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 15 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 15 (expression -> expression PLUS expression .) ]


state 82

    (16) expression -> expression MINUS expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 16 (expression -> expression MINUS expression .)
    KW_LET          reduce using rule 16 (expression -> expression MINUS expression .)
    KW_FN           reduce using rule 16 (expression -> expression MINUS expression .)
    VARIABLE        reduce using rule 16 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 16 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 16 (expression -> expression MINUS expression .)
    KW_FOR          reduce using rule 16 (expression -> expression MINUS expression .)
    KW_IF           reduce using rule 16 (expression -> expression MINUS expression .)
    KW_ELSE         reduce using rule 16 (expression -> expression MINUS expression .)
    KW_WHILE        reduce using rule 16 (expression -> expression MINUS expression .)
    INTEGER         reduce using rule 16 (expression -> expression MINUS expression .)
    FLOAT           reduce using rule 16 (expression -> expression MINUS expression .)
    KW_CONST        reduce using rule 16 (expression -> expression MINUS expression .)
    QUOTE           reduce using rule 16 (expression -> expression MINUS expression .)
    $end            reduce using rule 16 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 16 (expression -> expression MINUS expression .)
    KW_RETURN       reduce using rule 16 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 16 (expression -> expression MINUS expression .)
    SEMI            reduce using rule 16 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45

  ! PLUS            [ reduce using rule 16 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 16 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 16 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 16 (expression -> expression MINUS expression .) ]


state 83

    (17) expression -> expression TIMES expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 17 (expression -> expression TIMES expression .)
    KW_LET          reduce using rule 17 (expression -> expression TIMES expression .)
    KW_FN           reduce using rule 17 (expression -> expression TIMES expression .)
    VARIABLE        reduce using rule 17 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 17 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 17 (expression -> expression TIMES expression .)
    KW_FOR          reduce using rule 17 (expression -> expression TIMES expression .)
    KW_IF           reduce using rule 17 (expression -> expression TIMES expression .)
    KW_ELSE         reduce using rule 17 (expression -> expression TIMES expression .)
    KW_WHILE        reduce using rule 17 (expression -> expression TIMES expression .)
    INTEGER         reduce using rule 17 (expression -> expression TIMES expression .)
    FLOAT           reduce using rule 17 (expression -> expression TIMES expression .)
    KW_CONST        reduce using rule 17 (expression -> expression TIMES expression .)
    QUOTE           reduce using rule 17 (expression -> expression TIMES expression .)
    $end            reduce using rule 17 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 17 (expression -> expression TIMES expression .)
    KW_RETURN       reduce using rule 17 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 17 (expression -> expression TIMES expression .)
    SEMI            reduce using rule 17 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45

  ! PLUS            [ reduce using rule 17 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 17 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 17 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 17 (expression -> expression TIMES expression .) ]


state 84

    (18) expression -> expression DIVIDE expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_LET          reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_FN           reduce using rule 18 (expression -> expression DIVIDE expression .)
    VARIABLE        reduce using rule 18 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 18 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_FOR          reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_IF           reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_ELSE         reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_WHILE        reduce using rule 18 (expression -> expression DIVIDE expression .)
    INTEGER         reduce using rule 18 (expression -> expression DIVIDE expression .)
    FLOAT           reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_CONST        reduce using rule 18 (expression -> expression DIVIDE expression .)
    QUOTE           reduce using rule 18 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 18 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 18 (expression -> expression DIVIDE expression .)
    KW_RETURN       reduce using rule 18 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 18 (expression -> expression DIVIDE expression .)
    SEMI            reduce using rule 18 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45

  ! PLUS            [ reduce using rule 18 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 18 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 18 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> expression DIVIDE expression .) ]


state 85

    (58) print -> KW_PRINT LPAREN CADENA . RPAREN SEMI

    RPAREN          shift and go to state 116


state 86

    (19) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_PRINT        reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_LET          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_FN           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_FOR          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_IF           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_ELSE         reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_WHILE        reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_CONST        reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    QUOTE           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    KW_RETURN       reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    SEMI            reduce using rule 19 (expression -> LPAREN expression RPAREN .)


state 87

    (59) dvariable -> KW_LET VARIABLE SEMI .

    KW_PRINT        reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_LET          reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_FN           reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    VARIABLE        reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    LPAREN          reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    LBRACKET        reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_FOR          reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_IF           reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_ELSE         reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_WHILE        reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    INTEGER         reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    FLOAT           reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_CONST        reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    QUOTE           reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    $end            reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    RBRACE          reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_RETURN       reduce using rule 59 (dvariable -> KW_LET VARIABLE SEMI .)


state 88

    (60) array -> KW_LET VARIABLE EQUALS . LBRACKET mdata RBRACKET
    (96) hashmap -> KW_LET VARIABLE EQUALS . KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET VARIABLE EQUALS . KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (107) linkedlist -> KW_LET VARIABLE EQUALS . KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> KW_LET VARIABLE EQUALS . data
    (73) let_initialization -> KW_LET VARIABLE EQUALS . expression_var
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (117) expression_var -> . expression
    (118) expression_var -> . VARIABLE
    (65) tuple -> . LPAREN mdata RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    LBRACKET        shift and go to state 118
    KW_HASHMAP      shift and go to state 119
    KW_LINKEDLIST   shift and go to state 121
    CADENA          shift and go to state 61
    INTEGER         shift and go to state 124
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 125
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    VARIABLE        shift and go to state 117
    LPAREN          shift and go to state 120

    data                           shift and go to state 122
    expression_var                 shift and go to state 123
    tuple                          shift and go to state 67
    expression                     shift and go to state 126
    number                         shift and go to state 26

state 89

    (105) linkedlist -> KW_LET VARIABLE COLON . KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (70) let_initialization -> KW_LET VARIABLE COLON . data_type EQUALS data
    (74) let_initialization -> KW_LET VARIABLE COLON . data_type EQUALS expression_var
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    KW_LINKEDLIST   shift and go to state 127
    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 128

state 90

    (97) hashmap -> KW_LET KW_MUT VARIABLE . EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT VARIABLE . EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (106) linkedlist -> KW_LET KW_MUT VARIABLE . COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (108) linkedlist -> KW_LET KW_MUT VARIABLE . EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (71) let_initialization -> KW_LET KW_MUT VARIABLE . EQUALS data
    (72) let_initialization -> KW_LET KW_MUT VARIABLE . COLON data_type EQUALS data
    (75) let_initialization -> KW_LET KW_MUT VARIABLE . EQUALS expression_var
    (76) let_initialization -> KW_LET KW_MUT VARIABLE . COLON data_type EQUALS expression_var

    EQUALS          shift and go to state 143
    COLON           shift and go to state 144


state 91

    (62) variables -> VARIABLE .
    (63) variables -> VARIABLE . COMMA variables

    KW_PRINT        reduce using rule 62 (variables -> VARIABLE .)
    KW_LET          reduce using rule 62 (variables -> VARIABLE .)
    KW_FN           reduce using rule 62 (variables -> VARIABLE .)
    VARIABLE        reduce using rule 62 (variables -> VARIABLE .)
    LPAREN          reduce using rule 62 (variables -> VARIABLE .)
    LBRACKET        reduce using rule 62 (variables -> VARIABLE .)
    KW_FOR          reduce using rule 62 (variables -> VARIABLE .)
    KW_IF           reduce using rule 62 (variables -> VARIABLE .)
    KW_ELSE         reduce using rule 62 (variables -> VARIABLE .)
    KW_WHILE        reduce using rule 62 (variables -> VARIABLE .)
    INTEGER         reduce using rule 62 (variables -> VARIABLE .)
    FLOAT           reduce using rule 62 (variables -> VARIABLE .)
    KW_CONST        reduce using rule 62 (variables -> VARIABLE .)
    QUOTE           reduce using rule 62 (variables -> VARIABLE .)
    $end            reduce using rule 62 (variables -> VARIABLE .)
    RBRACE          reduce using rule 62 (variables -> VARIABLE .)
    KW_RETURN       reduce using rule 62 (variables -> VARIABLE .)
    RPAREN          reduce using rule 62 (variables -> VARIABLE .)
    COMMA           shift and go to state 52


state 92

    (63) variables -> VARIABLE COMMA variables .

    KW_PRINT        reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_LET          reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_FN           reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    VARIABLE        reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    LPAREN          reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    LBRACKET        reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_FOR          reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_IF           reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_ELSE         reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_WHILE        reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    INTEGER         reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    FLOAT           reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_CONST        reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    QUOTE           reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    $end            reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    RBRACE          reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    KW_RETURN       reduce using rule 63 (variables -> VARIABLE COMMA variables .)
    RPAREN          reduce using rule 63 (variables -> VARIABLE COMMA variables .)


state 93

    (111) linkedlist_push -> DOT KW_PUSH_BACK . LPAREN data RPAREN SEMI

    LPAREN          shift and go to state 145


state 94

    (112) linkedlist_remove -> DOT KW_REMOVE . LPAREN INTEGER RPAREN SEMI
    (103) hashmap_remove -> DOT KW_REMOVE . LPAREN AND data RPAREN SEMI

    LPAREN          shift and go to state 146


state 95

    (102) hashmap_insert -> DOT KW_INSERT . LPAREN mdata RPAREN SEMI

    LPAREN          shift and go to state 147


state 96

    (80) function -> KW_FN VARIABLE LPAREN . arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> KW_FN VARIABLE LPAREN . arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (78) arguments -> . void
    (79) arguments -> . variables
    (104) void -> .
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables

    RPAREN          reduce using rule 104 (void -> .)
    VARIABLE        shift and go to state 91

    arguments                      shift and go to state 148
    void                           shift and go to state 149
    variables                      shift and go to state 150

state 97

    (61) array -> LBRACKET mdata RBRACKET .

    KW_PRINT        reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_LET          reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_FN           reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    VARIABLE        reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    LPAREN          reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    LBRACKET        reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_FOR          reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_IF           reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_ELSE         reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_WHILE        reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    INTEGER         reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    FLOAT           reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_CONST        reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    QUOTE           reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    $end            reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    SEMI            reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    RBRACE          reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    KW_RETURN       reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)
    RPAREN          reduce using rule 61 (array -> LBRACKET mdata RBRACKET .)


state 98

    (57) mdata -> data COMMA . mdata
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 60
    mdata                          shift and go to state 151
    tuple                          shift and go to state 67

state 99

    (65) tuple -> LPAREN mdata . RPAREN

    RPAREN          shift and go to state 152


state 100

    (87) for_str -> KW_FOR VARIABLE KW_IN . range LBRACE main_rule RBRACE
    (88) for_str -> KW_FOR VARIABLE KW_IN . VARIABLE LBRACE main_rule RBRACE
    (90) range -> . INTEGER DOT DOT INTEGER
    (91) range -> . VARIABLE DOT DOT VARIABLE

    VARIABLE        shift and go to state 153
    INTEGER         shift and go to state 155

    range                          shift and go to state 154

state 101

    (89) for_str_tagged -> label COLON for_str .

    KW_PRINT        reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_LET          reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_FN           reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    VARIABLE        reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    LPAREN          reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    LBRACKET        reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_FOR          reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_IF           reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_ELSE         reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_WHILE        reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    INTEGER         reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    FLOAT           reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_CONST        reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    QUOTE           reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    $end            reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    RBRACE          reduce using rule 89 (for_str_tagged -> label COLON for_str .)
    KW_RETURN       reduce using rule 89 (for_str_tagged -> label COLON for_str .)


state 102

    (113) if -> KW_IF conditional LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 156
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 103

    (53) conditional -> VARIABLE comparator . data
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 157
    tuple                          shift and go to state 67

state 104

    (52) and -> VARIABLE LAND . VARIABLE

    VARIABLE        shift and go to state 158


state 105

    (46) comparator -> EQ .

    CADENA          reduce using rule 46 (comparator -> EQ .)
    INTEGER         reduce using rule 46 (comparator -> EQ .)
    CHAR            reduce using rule 46 (comparator -> EQ .)
    FLOAT           reduce using rule 46 (comparator -> EQ .)
    KW_FALSE        reduce using rule 46 (comparator -> EQ .)
    KW_TRUE         reduce using rule 46 (comparator -> EQ .)
    LPAREN          reduce using rule 46 (comparator -> EQ .)


state 106

    (47) comparator -> NE .

    CADENA          reduce using rule 47 (comparator -> NE .)
    INTEGER         reduce using rule 47 (comparator -> NE .)
    CHAR            reduce using rule 47 (comparator -> NE .)
    FLOAT           reduce using rule 47 (comparator -> NE .)
    KW_FALSE        reduce using rule 47 (comparator -> NE .)
    KW_TRUE         reduce using rule 47 (comparator -> NE .)
    LPAREN          reduce using rule 47 (comparator -> NE .)


state 107

    (48) comparator -> GE .

    CADENA          reduce using rule 48 (comparator -> GE .)
    INTEGER         reduce using rule 48 (comparator -> GE .)
    CHAR            reduce using rule 48 (comparator -> GE .)
    FLOAT           reduce using rule 48 (comparator -> GE .)
    KW_FALSE        reduce using rule 48 (comparator -> GE .)
    KW_TRUE         reduce using rule 48 (comparator -> GE .)
    LPAREN          reduce using rule 48 (comparator -> GE .)


state 108

    (49) comparator -> LE .

    CADENA          reduce using rule 49 (comparator -> LE .)
    INTEGER         reduce using rule 49 (comparator -> LE .)
    CHAR            reduce using rule 49 (comparator -> LE .)
    FLOAT           reduce using rule 49 (comparator -> LE .)
    KW_FALSE        reduce using rule 49 (comparator -> LE .)
    KW_TRUE         reduce using rule 49 (comparator -> LE .)
    LPAREN          reduce using rule 49 (comparator -> LE .)


state 109

    (50) comparator -> GT .

    CADENA          reduce using rule 50 (comparator -> GT .)
    INTEGER         reduce using rule 50 (comparator -> GT .)
    CHAR            reduce using rule 50 (comparator -> GT .)
    FLOAT           reduce using rule 50 (comparator -> GT .)
    KW_FALSE        reduce using rule 50 (comparator -> GT .)
    KW_TRUE         reduce using rule 50 (comparator -> GT .)
    LPAREN          reduce using rule 50 (comparator -> GT .)


state 110

    (51) comparator -> LT .

    CADENA          reduce using rule 51 (comparator -> LT .)
    INTEGER         reduce using rule 51 (comparator -> LT .)
    CHAR            reduce using rule 51 (comparator -> LT .)
    FLOAT           reduce using rule 51 (comparator -> LT .)
    KW_FALSE        reduce using rule 51 (comparator -> LT .)
    KW_TRUE         reduce using rule 51 (comparator -> LT .)
    LPAREN          reduce using rule 51 (comparator -> LT .)


state 111

    (54) conditional -> and comparator . data
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 159
    tuple                          shift and go to state 67

state 112

    (114) else -> KW_ELSE LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 160


state 113

    (115) else_if -> KW_ELSE KW_IF conditional . LBRACE main_rule RBRACE

    LBRACE          shift and go to state 161


state 114

    (64) while -> KW_WHILE LPAREN VARIABLE .

    KW_PRINT        reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_LET          reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_FN           reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    VARIABLE        reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    LPAREN          reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    LBRACKET        reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_FOR          reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_IF           reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_ELSE         reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_WHILE        reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    INTEGER         reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    FLOAT           reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_CONST        reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    QUOTE           reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    $end            reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    RBRACE          reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)
    KW_RETURN       reduce using rule 64 (while -> KW_WHILE LPAREN VARIABLE .)


state 115

    (77) const_initialization -> KW_CONST VARIABLE COLON . data_type EQUALS data
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 162

state 116

    (58) print -> KW_PRINT LPAREN CADENA RPAREN . SEMI

    SEMI            shift and go to state 163


state 117

    (118) expression_var -> VARIABLE .
    (23) number -> VARIABLE .

  ! reduce/reduce conflict for SEMI resolved using rule 23 (number -> VARIABLE .)
    PLUS            reduce using rule 23 (number -> VARIABLE .)
    MINUS           reduce using rule 23 (number -> VARIABLE .)
    TIMES           reduce using rule 23 (number -> VARIABLE .)
    DIVIDE          reduce using rule 23 (number -> VARIABLE .)
    SEMI            reduce using rule 23 (number -> VARIABLE .)

  ! SEMI            [ reduce using rule 118 (expression_var -> VARIABLE .) ]


state 118

    (60) array -> KW_LET VARIABLE EQUALS LBRACKET . mdata RBRACKET
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    mdata                          shift and go to state 164
    data                           shift and go to state 60
    tuple                          shift and go to state 67

state 119

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP . COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP . COLON COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 165


state 120

    (65) tuple -> LPAREN . mdata RPAREN
    (19) expression -> LPAREN . expression RPAREN
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (65) tuple -> . LPAREN mdata RPAREN

    LPAREN          shift and go to state 166
    CADENA          shift and go to state 61
    INTEGER         shift and go to state 124
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 125
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    VARIABLE        shift and go to state 49

    mdata                          shift and go to state 99
    expression                     shift and go to state 48
    data                           shift and go to state 60
    number                         shift and go to state 26
    tuple                          shift and go to state 67

state 121

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST . COLON COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 167


state 122

    (69) let_initialization -> KW_LET VARIABLE EQUALS data .

    SEMI            reduce using rule 69 (let_initialization -> KW_LET VARIABLE EQUALS data .)


state 123

    (73) let_initialization -> KW_LET VARIABLE EQUALS expression_var .

    SEMI            reduce using rule 73 (let_initialization -> KW_LET VARIABLE EQUALS expression_var .)


state 124

    (39) data -> INTEGER .
    (21) number -> INTEGER .

  ! reduce/reduce conflict for SEMI resolved using rule 21 (number -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 21 (number -> INTEGER .)
    COMMA           reduce using rule 39 (data -> INTEGER .)
    PLUS            reduce using rule 21 (number -> INTEGER .)
    MINUS           reduce using rule 21 (number -> INTEGER .)
    TIMES           reduce using rule 21 (number -> INTEGER .)
    DIVIDE          reduce using rule 21 (number -> INTEGER .)
    SEMI            reduce using rule 21 (number -> INTEGER .)
    RPAREN          reduce using rule 21 (number -> INTEGER .)

  ! SEMI            [ reduce using rule 39 (data -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 39 (data -> INTEGER .) ]


state 125

    (41) data -> FLOAT .
    (22) number -> FLOAT .

  ! reduce/reduce conflict for SEMI resolved using rule 22 (number -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 22 (number -> FLOAT .)
    COMMA           reduce using rule 41 (data -> FLOAT .)
    PLUS            reduce using rule 22 (number -> FLOAT .)
    MINUS           reduce using rule 22 (number -> FLOAT .)
    TIMES           reduce using rule 22 (number -> FLOAT .)
    DIVIDE          reduce using rule 22 (number -> FLOAT .)
    SEMI            reduce using rule 22 (number -> FLOAT .)
    RPAREN          reduce using rule 22 (number -> FLOAT .)

  ! SEMI            [ reduce using rule 41 (data -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 41 (data -> FLOAT .) ]


state 126

    (117) expression_var -> expression .
    (15) expression -> expression . PLUS expression
    (16) expression -> expression . MINUS expression
    (17) expression -> expression . TIMES expression
    (18) expression -> expression . DIVIDE expression

    SEMI            reduce using rule 117 (expression_var -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45


state 127

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST . LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    LT              shift and go to state 168


state 128

    (70) let_initialization -> KW_LET VARIABLE COLON data_type . EQUALS data
    (74) let_initialization -> KW_LET VARIABLE COLON data_type . EQUALS expression_var

    EQUALS          shift and go to state 169


state 129

    (24) data_type -> UNSIG_INT_8 .

    EQUALS          reduce using rule 24 (data_type -> UNSIG_INT_8 .)
    GT              reduce using rule 24 (data_type -> UNSIG_INT_8 .)
    LBRACE          reduce using rule 24 (data_type -> UNSIG_INT_8 .)


state 130

    (25) data_type -> UNSIG_INT_16 .

    EQUALS          reduce using rule 25 (data_type -> UNSIG_INT_16 .)
    GT              reduce using rule 25 (data_type -> UNSIG_INT_16 .)
    LBRACE          reduce using rule 25 (data_type -> UNSIG_INT_16 .)


state 131

    (26) data_type -> UNSIG_INT_32 .

    EQUALS          reduce using rule 26 (data_type -> UNSIG_INT_32 .)
    GT              reduce using rule 26 (data_type -> UNSIG_INT_32 .)
    LBRACE          reduce using rule 26 (data_type -> UNSIG_INT_32 .)


state 132

    (27) data_type -> UNSIG_INT_64 .

    EQUALS          reduce using rule 27 (data_type -> UNSIG_INT_64 .)
    GT              reduce using rule 27 (data_type -> UNSIG_INT_64 .)
    LBRACE          reduce using rule 27 (data_type -> UNSIG_INT_64 .)


state 133

    (28) data_type -> UNSIG_INT_128 .

    EQUALS          reduce using rule 28 (data_type -> UNSIG_INT_128 .)
    GT              reduce using rule 28 (data_type -> UNSIG_INT_128 .)
    LBRACE          reduce using rule 28 (data_type -> UNSIG_INT_128 .)


state 134

    (29) data_type -> SIG_INT_8 .

    EQUALS          reduce using rule 29 (data_type -> SIG_INT_8 .)
    GT              reduce using rule 29 (data_type -> SIG_INT_8 .)
    LBRACE          reduce using rule 29 (data_type -> SIG_INT_8 .)


state 135

    (30) data_type -> SIG_INT_16 .

    EQUALS          reduce using rule 30 (data_type -> SIG_INT_16 .)
    GT              reduce using rule 30 (data_type -> SIG_INT_16 .)
    LBRACE          reduce using rule 30 (data_type -> SIG_INT_16 .)


state 136

    (31) data_type -> SIG_INT_32 .

    EQUALS          reduce using rule 31 (data_type -> SIG_INT_32 .)
    GT              reduce using rule 31 (data_type -> SIG_INT_32 .)
    LBRACE          reduce using rule 31 (data_type -> SIG_INT_32 .)


state 137

    (32) data_type -> SIG_INT_64 .

    EQUALS          reduce using rule 32 (data_type -> SIG_INT_64 .)
    GT              reduce using rule 32 (data_type -> SIG_INT_64 .)
    LBRACE          reduce using rule 32 (data_type -> SIG_INT_64 .)


state 138

    (33) data_type -> SIG_INT_128 .

    EQUALS          reduce using rule 33 (data_type -> SIG_INT_128 .)
    GT              reduce using rule 33 (data_type -> SIG_INT_128 .)
    LBRACE          reduce using rule 33 (data_type -> SIG_INT_128 .)


state 139

    (34) data_type -> FLOAT_32 .

    EQUALS          reduce using rule 34 (data_type -> FLOAT_32 .)
    GT              reduce using rule 34 (data_type -> FLOAT_32 .)
    LBRACE          reduce using rule 34 (data_type -> FLOAT_32 .)


state 140

    (35) data_type -> FLOAT_64 .

    EQUALS          reduce using rule 35 (data_type -> FLOAT_64 .)
    GT              reduce using rule 35 (data_type -> FLOAT_64 .)
    LBRACE          reduce using rule 35 (data_type -> FLOAT_64 .)


state 141

    (36) data_type -> KW_BOOLEAN .

    EQUALS          reduce using rule 36 (data_type -> KW_BOOLEAN .)
    GT              reduce using rule 36 (data_type -> KW_BOOLEAN .)
    LBRACE          reduce using rule 36 (data_type -> KW_BOOLEAN .)


state 142

    (37) data_type -> KW_STRING .

    EQUALS          reduce using rule 37 (data_type -> KW_STRING .)
    GT              reduce using rule 37 (data_type -> KW_STRING .)
    LBRACE          reduce using rule 37 (data_type -> KW_STRING .)


state 143

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS . KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS . KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS . KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (71) let_initialization -> KW_LET KW_MUT VARIABLE EQUALS . data
    (75) let_initialization -> KW_LET KW_MUT VARIABLE EQUALS . expression_var
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (117) expression_var -> . expression
    (118) expression_var -> . VARIABLE
    (65) tuple -> . LPAREN mdata RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    KW_HASHMAP      shift and go to state 170
    KW_LINKEDLIST   shift and go to state 171
    CADENA          shift and go to state 61
    INTEGER         shift and go to state 124
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 125
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    VARIABLE        shift and go to state 117
    LPAREN          shift and go to state 120

    data                           shift and go to state 172
    expression_var                 shift and go to state 173
    tuple                          shift and go to state 67
    expression                     shift and go to state 126
    number                         shift and go to state 26

state 144

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON . KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (72) let_initialization -> KW_LET KW_MUT VARIABLE COLON . data_type EQUALS data
    (76) let_initialization -> KW_LET KW_MUT VARIABLE COLON . data_type EQUALS expression_var
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    KW_LINKEDLIST   shift and go to state 174
    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 175

state 145

    (111) linkedlist_push -> DOT KW_PUSH_BACK LPAREN . data RPAREN SEMI
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 176
    tuple                          shift and go to state 67

state 146

    (112) linkedlist_remove -> DOT KW_REMOVE LPAREN . INTEGER RPAREN SEMI
    (103) hashmap_remove -> DOT KW_REMOVE LPAREN . AND data RPAREN SEMI

    INTEGER         shift and go to state 177
    AND             shift and go to state 178


state 147

    (102) hashmap_insert -> DOT KW_INSERT LPAREN . mdata RPAREN SEMI
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    mdata                          shift and go to state 179
    data                           shift and go to state 60
    tuple                          shift and go to state 67

state 148

    (80) function -> KW_FN VARIABLE LPAREN arguments . RPAREN LBRACE main_rule RBRACE
    (116) function -> KW_FN VARIABLE LPAREN arguments . RPAREN MINUS GT data_type LBRACE return RBRACE

    RPAREN          shift and go to state 180


state 149

    (78) arguments -> void .

    RPAREN          reduce using rule 78 (arguments -> void .)


state 150

    (79) arguments -> variables .

    RPAREN          reduce using rule 79 (arguments -> variables .)


state 151

    (57) mdata -> data COMMA mdata .

    RBRACKET        reduce using rule 57 (mdata -> data COMMA mdata .)
    RPAREN          reduce using rule 57 (mdata -> data COMMA mdata .)


state 152

    (65) tuple -> LPAREN mdata RPAREN .

    COMMA           reduce using rule 65 (tuple -> LPAREN mdata RPAREN .)
    RBRACKET        reduce using rule 65 (tuple -> LPAREN mdata RPAREN .)
    RPAREN          reduce using rule 65 (tuple -> LPAREN mdata RPAREN .)
    SEMI            reduce using rule 65 (tuple -> LPAREN mdata RPAREN .)
    LBRACE          reduce using rule 65 (tuple -> LPAREN mdata RPAREN .)


state 153

    (88) for_str -> KW_FOR VARIABLE KW_IN VARIABLE . LBRACE main_rule RBRACE
    (91) range -> VARIABLE . DOT DOT VARIABLE

    LBRACE          shift and go to state 181
    DOT             shift and go to state 182


state 154

    (87) for_str -> KW_FOR VARIABLE KW_IN range . LBRACE main_rule RBRACE

    LBRACE          shift and go to state 183


state 155

    (90) range -> INTEGER . DOT DOT INTEGER

    DOT             shift and go to state 184


state 156

    (113) if -> KW_IF conditional LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 185


state 157

    (53) conditional -> VARIABLE comparator data .

    LBRACE          reduce using rule 53 (conditional -> VARIABLE comparator data .)


state 158

    (52) and -> VARIABLE LAND VARIABLE .

    EQ              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    NE              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    GE              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    LE              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    GT              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    LT              reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    CADENA          reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    INTEGER         reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    CHAR            reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    FLOAT           reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    KW_FALSE        reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    KW_TRUE         reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)
    LPAREN          reduce using rule 52 (and -> VARIABLE LAND VARIABLE .)


state 159

    (54) conditional -> and comparator data .

    LBRACE          reduce using rule 54 (conditional -> and comparator data .)


state 160

    (114) else -> KW_ELSE LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    $end            reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 114 (else -> KW_ELSE LBRACE main_rule RBRACE .)


state 161

    (115) else_if -> KW_ELSE KW_IF conditional LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 186
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 162

    (77) const_initialization -> KW_CONST VARIABLE COLON data_type . EQUALS data

    EQUALS          shift and go to state 187


state 163

    (58) print -> KW_PRINT LPAREN CADENA RPAREN SEMI .

    KW_PRINT        reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_LET          reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_FN           reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    VARIABLE        reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    LPAREN          reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    LBRACKET        reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_FOR          reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_IF           reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_ELSE         reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_WHILE        reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    INTEGER         reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    FLOAT           reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_CONST        reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    QUOTE           reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    $end            reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    RBRACE          reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_RETURN       reduce using rule 58 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)


state 164

    (60) array -> KW_LET VARIABLE EQUALS LBRACKET mdata . RBRACKET

    RBRACKET        shift and go to state 188


state 165

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON . COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON . COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 189


state 166

    (19) expression -> LPAREN . expression RPAREN
    (65) tuple -> LPAREN . mdata RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (56) mdata -> . data
    (57) mdata -> . data COMMA mdata
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    LPAREN          shift and go to state 166
    INTEGER         shift and go to state 190
    FLOAT           shift and go to state 191
    VARIABLE        shift and go to state 49
    CADENA          shift and go to state 61
    CHAR            shift and go to state 63
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66

    expression                     shift and go to state 48
    mdata                          shift and go to state 99
    number                         shift and go to state 26
    data                           shift and go to state 60
    tuple                          shift and go to state 67

state 167

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON . COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 192


state 168

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT . data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 193

state 169

    (70) let_initialization -> KW_LET VARIABLE COLON data_type EQUALS . data
    (74) let_initialization -> KW_LET VARIABLE COLON data_type EQUALS . expression_var
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (117) expression_var -> . expression
    (118) expression_var -> . VARIABLE
    (65) tuple -> . LPAREN mdata RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 124
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 125
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    VARIABLE        shift and go to state 117
    LPAREN          shift and go to state 120

    data                           shift and go to state 194
    expression_var                 shift and go to state 195
    tuple                          shift and go to state 67
    expression                     shift and go to state 126
    number                         shift and go to state 26

state 170

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP . COLON COLON KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP . COLON COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 196


state 171

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST . COLON COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 197


state 172

    (71) let_initialization -> KW_LET KW_MUT VARIABLE EQUALS data .

    SEMI            reduce using rule 71 (let_initialization -> KW_LET KW_MUT VARIABLE EQUALS data .)


state 173

    (75) let_initialization -> KW_LET KW_MUT VARIABLE EQUALS expression_var .

    SEMI            reduce using rule 75 (let_initialization -> KW_LET KW_MUT VARIABLE EQUALS expression_var .)


state 174

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST . LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    LT              shift and go to state 198


state 175

    (72) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type . EQUALS data
    (76) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type . EQUALS expression_var

    EQUALS          shift and go to state 199


state 176

    (111) linkedlist_push -> DOT KW_PUSH_BACK LPAREN data . RPAREN SEMI

    RPAREN          shift and go to state 200


state 177

    (112) linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER . RPAREN SEMI

    RPAREN          shift and go to state 201


state 178

    (103) hashmap_remove -> DOT KW_REMOVE LPAREN AND . data RPAREN SEMI
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 202
    tuple                          shift and go to state 67

state 179

    (102) hashmap_insert -> DOT KW_INSERT LPAREN mdata . RPAREN SEMI

    RPAREN          shift and go to state 203


state 180

    (80) function -> KW_FN VARIABLE LPAREN arguments RPAREN . LBRACE main_rule RBRACE
    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN . MINUS GT data_type LBRACE return RBRACE

    LBRACE          shift and go to state 204
    MINUS           shift and go to state 205


state 181

    (88) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 206
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 182

    (91) range -> VARIABLE DOT . DOT VARIABLE

    DOT             shift and go to state 207


state 183

    (87) for_str -> KW_FOR VARIABLE KW_IN range LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 208
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 184

    (90) range -> INTEGER DOT . DOT INTEGER

    DOT             shift and go to state 209


state 185

    (113) if -> KW_IF conditional LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    $end            reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 113 (if -> KW_IF conditional LBRACE main_rule RBRACE .)


state 186

    (115) else_if -> KW_ELSE KW_IF conditional LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 210


state 187

    (77) const_initialization -> KW_CONST VARIABLE COLON data_type EQUALS . data
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (65) tuple -> . LPAREN mdata RPAREN

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    LPAREN          shift and go to state 68

    data                           shift and go to state 211
    tuple                          shift and go to state 67

state 188

    (60) array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .

    KW_PRINT        reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_LET          reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_FN           reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    VARIABLE        reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    LPAREN          reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    LBRACKET        reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_FOR          reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_IF           reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_ELSE         reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_WHILE        reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    INTEGER         reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    FLOAT           reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_CONST        reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    QUOTE           reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    $end            reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    SEMI            reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    RBRACE          reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_RETURN       reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    RPAREN          reduce using rule 60 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)


state 189

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON . KW_NEW LPAREN RPAREN
    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON . KW_FROM LPAREN array RPAREN

    KW_NEW          shift and go to state 212
    KW_FROM         shift and go to state 213


state 190

    (21) number -> INTEGER .
    (39) data -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 21 (number -> INTEGER .)
    RPAREN          reduce using rule 21 (number -> INTEGER .)
    PLUS            reduce using rule 21 (number -> INTEGER .)
    MINUS           reduce using rule 21 (number -> INTEGER .)
    TIMES           reduce using rule 21 (number -> INTEGER .)
    DIVIDE          reduce using rule 21 (number -> INTEGER .)
    COMMA           reduce using rule 39 (data -> INTEGER .)

  ! RPAREN          [ reduce using rule 39 (data -> INTEGER .) ]


state 191

    (22) number -> FLOAT .
    (41) data -> FLOAT .

  ! reduce/reduce conflict for RPAREN resolved using rule 22 (number -> FLOAT .)
    RPAREN          reduce using rule 22 (number -> FLOAT .)
    PLUS            reduce using rule 22 (number -> FLOAT .)
    MINUS           reduce using rule 22 (number -> FLOAT .)
    TIMES           reduce using rule 22 (number -> FLOAT .)
    DIVIDE          reduce using rule 22 (number -> FLOAT .)
    COMMA           reduce using rule 41 (data -> FLOAT .)

  ! RPAREN          [ reduce using rule 41 (data -> FLOAT .) ]


state 192

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON . KW_FROM LPAREN array RPAREN

    KW_FROM         shift and go to state 214


state 193

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type . GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    GT              shift and go to state 215


state 194

    (70) let_initialization -> KW_LET VARIABLE COLON data_type EQUALS data .

    SEMI            reduce using rule 70 (let_initialization -> KW_LET VARIABLE COLON data_type EQUALS data .)


state 195

    (74) let_initialization -> KW_LET VARIABLE COLON data_type EQUALS expression_var .

    SEMI            reduce using rule 74 (let_initialization -> KW_LET VARIABLE COLON data_type EQUALS expression_var .)


state 196

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON . COLON KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON . COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 216


state 197

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON . COLON KW_FROM LPAREN array RPAREN

    COLON           shift and go to state 217


state 198

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT . data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 218

state 199

    (72) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS . data
    (76) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS . expression_var
    (38) data -> . CADENA
    (39) data -> . INTEGER
    (40) data -> . CHAR
    (41) data -> . FLOAT
    (42) data -> . KW_FALSE
    (43) data -> . KW_TRUE
    (44) data -> . tuple
    (117) expression_var -> . expression
    (118) expression_var -> . VARIABLE
    (65) tuple -> . LPAREN mdata RPAREN
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    CADENA          shift and go to state 61
    INTEGER         shift and go to state 124
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 125
    KW_FALSE        shift and go to state 65
    KW_TRUE         shift and go to state 66
    VARIABLE        shift and go to state 117
    LPAREN          shift and go to state 120

    data                           shift and go to state 219
    expression_var                 shift and go to state 220
    tuple                          shift and go to state 67
    expression                     shift and go to state 126
    number                         shift and go to state 26

state 200

    (111) linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN . SEMI

    SEMI            shift and go to state 221


state 201

    (112) linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN . SEMI

    SEMI            shift and go to state 222


state 202

    (103) hashmap_remove -> DOT KW_REMOVE LPAREN AND data . RPAREN SEMI

    RPAREN          shift and go to state 223


state 203

    (102) hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN . SEMI

    SEMI            shift and go to state 224


state 204

    (80) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    main_rule                      shift and go to state 225
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 205

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS . GT data_type LBRACE return RBRACE

    GT              shift and go to state 226


state 206

    (88) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 227


state 207

    (91) range -> VARIABLE DOT DOT . VARIABLE

    VARIABLE        shift and go to state 228


state 208

    (87) for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 229


state 209

    (90) range -> INTEGER DOT DOT . INTEGER

    INTEGER         shift and go to state 230


state 210

    (115) else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    $end            reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 115 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)


state 211

    (77) const_initialization -> KW_CONST VARIABLE COLON data_type EQUALS data .

    SEMI            reduce using rule 77 (const_initialization -> KW_CONST VARIABLE COLON data_type EQUALS data .)


state 212

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW . LPAREN RPAREN

    LPAREN          shift and go to state 231


state 213

    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM . LPAREN array RPAREN

    LPAREN          shift and go to state 232


state 214

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM . LPAREN array RPAREN

    LPAREN          shift and go to state 233


state 215

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT . EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    EQUALS          shift and go to state 234


state 216

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON . KW_NEW LPAREN RPAREN
    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON . KW_FROM LPAREN array RPAREN

    KW_NEW          shift and go to state 235
    KW_FROM         shift and go to state 236


state 217

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON . KW_FROM LPAREN array RPAREN

    KW_FROM         shift and go to state 237


state 218

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type . GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    GT              shift and go to state 238


state 219

    (72) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS data .

    SEMI            reduce using rule 72 (let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS data .)


state 220

    (76) let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var .

    SEMI            reduce using rule 76 (let_initialization -> KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var .)


state 221

    (111) linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .

    KW_PRINT        reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_LET          reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_FN           reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    VARIABLE        reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    LPAREN          reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    LBRACKET        reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_FOR          reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_IF           reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_ELSE         reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_WHILE        reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    INTEGER         reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    FLOAT           reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_CONST        reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    QUOTE           reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    $end            reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    RBRACE          reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)
    KW_RETURN       reduce using rule 111 (linkedlist_push -> DOT KW_PUSH_BACK LPAREN data RPAREN SEMI .)


state 222

    (112) linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .

    KW_PRINT        reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_LET          reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_FN           reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    VARIABLE        reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    LPAREN          reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    LBRACKET        reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_FOR          reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_IF           reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_ELSE         reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_WHILE        reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    INTEGER         reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    FLOAT           reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_CONST        reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    QUOTE           reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    $end            reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    RBRACE          reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_RETURN       reduce using rule 112 (linkedlist_remove -> DOT KW_REMOVE LPAREN INTEGER RPAREN SEMI .)


state 223

    (103) hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN . SEMI

    SEMI            shift and go to state 239


state 224

    (102) hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .

    KW_PRINT        reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_LET          reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_FN           reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    VARIABLE        reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    LPAREN          reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    LBRACKET        reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_FOR          reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_IF           reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_ELSE         reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_WHILE        reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    INTEGER         reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    FLOAT           reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_CONST        reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    QUOTE           reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    $end            reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    RBRACE          reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)
    KW_RETURN       reduce using rule 102 (hashmap_insert -> DOT KW_INSERT LPAREN mdata RPAREN SEMI .)


state 225

    (80) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 240


state 226

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT . data_type LBRACE return RBRACE
    (24) data_type -> . UNSIG_INT_8
    (25) data_type -> . UNSIG_INT_16
    (26) data_type -> . UNSIG_INT_32
    (27) data_type -> . UNSIG_INT_64
    (28) data_type -> . UNSIG_INT_128
    (29) data_type -> . SIG_INT_8
    (30) data_type -> . SIG_INT_16
    (31) data_type -> . SIG_INT_32
    (32) data_type -> . SIG_INT_64
    (33) data_type -> . SIG_INT_128
    (34) data_type -> . FLOAT_32
    (35) data_type -> . FLOAT_64
    (36) data_type -> . KW_BOOLEAN
    (37) data_type -> . KW_STRING

    UNSIG_INT_8     shift and go to state 129
    UNSIG_INT_16    shift and go to state 130
    UNSIG_INT_32    shift and go to state 131
    UNSIG_INT_64    shift and go to state 132
    UNSIG_INT_128   shift and go to state 133
    SIG_INT_8       shift and go to state 134
    SIG_INT_16      shift and go to state 135
    SIG_INT_32      shift and go to state 136
    SIG_INT_64      shift and go to state 137
    SIG_INT_128     shift and go to state 138
    FLOAT_32        shift and go to state 139
    FLOAT_64        shift and go to state 140
    KW_BOOLEAN      shift and go to state 141
    KW_STRING       shift and go to state 142

    data_type                      shift and go to state 241

state 227

    (88) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    $end            reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 88 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE .)


state 228

    (91) range -> VARIABLE DOT DOT VARIABLE .

    LBRACE          reduce using rule 91 (range -> VARIABLE DOT DOT VARIABLE .)


state 229

    (87) for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    $end            reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 87 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE .)


state 230

    (90) range -> INTEGER DOT DOT INTEGER .

    LBRACE          reduce using rule 90 (range -> INTEGER DOT DOT INTEGER .)


state 231

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN . RPAREN

    RPAREN          shift and go to state 242


state 232

    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN . array RPAREN
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 243
    LBRACKET        shift and go to state 29

    array                          shift and go to state 244

state 233

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN . array RPAREN
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 243
    LBRACKET        shift and go to state 29

    array                          shift and go to state 245

state 234

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS . KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    KW_LINKEDLIST   shift and go to state 246


state 235

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW . LPAREN RPAREN

    LPAREN          shift and go to state 247


state 236

    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM . LPAREN array RPAREN

    LPAREN          shift and go to state 248


state 237

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM . LPAREN array RPAREN

    LPAREN          shift and go to state 249


state 238

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT . EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    EQUALS          shift and go to state 250


state 239

    (103) hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .

    KW_PRINT        reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_LET          reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_FN           reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    VARIABLE        reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    LPAREN          reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    LBRACKET        reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_FOR          reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_IF           reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_ELSE         reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_WHILE        reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    INTEGER         reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    FLOAT           reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_CONST        reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    QUOTE           reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    $end            reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    RBRACE          reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)
    KW_RETURN       reduce using rule 103 (hashmap_remove -> DOT KW_REMOVE LPAREN AND data RPAREN SEMI .)


state 240

    (80) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_WHILE        reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_CONST        reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    $end            reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 80 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE .)


state 241

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type . LBRACE return RBRACE

    LBRACE          shift and go to state 251


state 242

    (96) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .

    SEMI            reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_PRINT        reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_LET          reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FN           reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    VARIABLE        reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    LPAREN          reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    LBRACKET        reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FOR          reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_IF           reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_ELSE         reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_WHILE        reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    INTEGER         reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    FLOAT           reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_CONST        reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    QUOTE           reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    $end            reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    RBRACE          reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_RETURN       reduce using rule 96 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)


state 243

    (60) array -> KW_LET . VARIABLE EQUALS LBRACKET mdata RBRACKET

    VARIABLE        shift and go to state 252


state 244

    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array . RPAREN

    RPAREN          shift and go to state 253


state 245

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array . RPAREN

    RPAREN          shift and go to state 254


state 246

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST . COLON COLON KW_NEW LPAREN RPAREN

    COLON           shift and go to state 255


state 247

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN . RPAREN

    RPAREN          shift and go to state 256


state 248

    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN . array RPAREN
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 243
    LBRACKET        shift and go to state 29

    array                          shift and go to state 257

state 249

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN . array RPAREN
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 243
    LBRACKET        shift and go to state 29

    array                          shift and go to state 258

state 250

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS . KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN

    KW_LINKEDLIST   shift and go to state 259


state 251

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE . return RBRACE
    (119) return -> . main_rule
    (120) return -> . main_rule KW_RETURN expression_var SEMI
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . function
    (6) father_rule -> . variables
    (7) father_rule -> . control_str
    (8) father_rule -> . expression
    (9) father_rule -> . void
    (10) father_rule -> . data_str
    (11) father_rule -> . array
    (12) father_rule -> . linkedlist_methods
    (13) father_rule -> . hashmap_methods
    (14) father_rule -> . initialization
    (58) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (59) dvariable -> . KW_LET VARIABLE SEMI
    (80) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE main_rule RBRACE
    (116) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE
    (62) variables -> . VARIABLE
    (63) variables -> . VARIABLE COMMA variables
    (81) control_str -> . for_str
    (82) control_str -> . for_str_tagged
    (83) control_str -> . if
    (84) control_str -> . else
    (85) control_str -> . else_if
    (86) control_str -> . while
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (104) void -> .
    (93) data_str -> . array
    (94) data_str -> . hashmap
    (95) data_str -> . linkedlist
    (60) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (61) array -> . LBRACKET mdata RBRACKET
    (109) linkedlist_methods -> . VARIABLE linkedlist_push
    (110) linkedlist_methods -> . VARIABLE linkedlist_remove
    (100) hashmap_methods -> . VARIABLE hashmap_insert
    (101) hashmap_methods -> . VARIABLE hashmap_remove
    (66) initialization -> . let_initialization SEMI
    (67) initialization -> . const_initialization SEMI
    (68) initialization -> . data_str SEMI
    (87) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE main_rule RBRACE
    (88) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE main_rule RBRACE
    (89) for_str_tagged -> . label COLON for_str
    (113) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (114) else -> . KW_ELSE LBRACE main_rule RBRACE
    (115) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (64) while -> . KW_WHILE LPAREN VARIABLE
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE
    (96) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (97) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN
    (98) hashmap -> . KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (99) hashmap -> . KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN
    (105) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (106) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN
    (107) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (108) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN
    (69) let_initialization -> . KW_LET VARIABLE EQUALS data
    (70) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS data
    (71) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS data
    (72) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS data
    (73) let_initialization -> . KW_LET VARIABLE EQUALS expression_var
    (74) let_initialization -> . KW_LET VARIABLE COLON data_type EQUALS expression_var
    (75) let_initialization -> . KW_LET KW_MUT VARIABLE EQUALS expression_var
    (76) let_initialization -> . KW_LET KW_MUT VARIABLE COLON data_type EQUALS expression_var
    (77) const_initialization -> . KW_CONST VARIABLE COLON data_type EQUALS data
    (92) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_WHILE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KW_CONST resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 15
    KW_LET          shift and go to state 17
    KW_FN           shift and go to state 19
    VARIABLE        shift and go to state 18
    LPAREN          shift and go to state 16
    KW_RETURN       reduce using rule 104 (void -> .)
    RBRACE          reduce using rule 104 (void -> .)
    LBRACKET        shift and go to state 29
    KW_FOR          shift and go to state 32
    KW_IF           shift and go to state 34
    KW_ELSE         shift and go to state 35
    KW_WHILE        shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    KW_CONST        shift and go to state 39
    QUOTE           shift and go to state 40

  ! KW_PRINT        [ reduce using rule 104 (void -> .) ]
  ! KW_LET          [ reduce using rule 104 (void -> .) ]
  ! KW_FN           [ reduce using rule 104 (void -> .) ]
  ! VARIABLE        [ reduce using rule 104 (void -> .) ]
  ! LPAREN          [ reduce using rule 104 (void -> .) ]
  ! LBRACKET        [ reduce using rule 104 (void -> .) ]
  ! KW_FOR          [ reduce using rule 104 (void -> .) ]
  ! KW_IF           [ reduce using rule 104 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 104 (void -> .) ]
  ! KW_WHILE        [ reduce using rule 104 (void -> .) ]
  ! INTEGER         [ reduce using rule 104 (void -> .) ]
  ! FLOAT           [ reduce using rule 104 (void -> .) ]
  ! KW_CONST        [ reduce using rule 104 (void -> .) ]
  ! QUOTE           [ reduce using rule 104 (void -> .) ]

    return                         shift and go to state 260
    main_rule                      shift and go to state 261
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    function                       shift and go to state 5
    variables                      shift and go to state 6
    control_str                    shift and go to state 7
    expression                     shift and go to state 8
    void                           shift and go to state 9
    data_str                       shift and go to state 10
    array                          shift and go to state 11
    linkedlist_methods             shift and go to state 12
    hashmap_methods                shift and go to state 13
    initialization                 shift and go to state 14
    for_str                        shift and go to state 20
    for_str_tagged                 shift and go to state 21
    if                             shift and go to state 22
    else                           shift and go to state 23
    else_if                        shift and go to state 24
    while                          shift and go to state 25
    number                         shift and go to state 26
    hashmap                        shift and go to state 27
    linkedlist                     shift and go to state 28
    let_initialization             shift and go to state 30
    const_initialization           shift and go to state 31
    label                          shift and go to state 33

state 252

    (60) array -> KW_LET VARIABLE . EQUALS LBRACKET mdata RBRACKET

    EQUALS          shift and go to state 262


state 253

    (98) hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .

    SEMI            reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_PRINT        reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_LET          reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FN           reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    VARIABLE        reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    LPAREN          reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    LBRACKET        reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FOR          reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_IF           reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_ELSE         reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_WHILE        reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    INTEGER         reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    FLOAT           reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_CONST        reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    QUOTE           reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    $end            reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    RBRACE          reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_RETURN       reduce using rule 98 (hashmap -> KW_LET VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)


state 254

    (107) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .

    SEMI            reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_PRINT        reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_LET          reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FN           reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    VARIABLE        reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    LPAREN          reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    LBRACKET        reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FOR          reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_IF           reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_ELSE         reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_WHILE        reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    INTEGER         reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    FLOAT           reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_CONST        reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    QUOTE           reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    $end            reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    RBRACE          reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_RETURN       reduce using rule 107 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)


state 255

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON . COLON KW_NEW LPAREN RPAREN

    COLON           shift and go to state 263


state 256

    (97) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .

    SEMI            reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_PRINT        reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_LET          reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FN           reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    VARIABLE        reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    LPAREN          reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    LBRACKET        reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FOR          reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_IF           reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_ELSE         reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_WHILE        reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    INTEGER         reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    FLOAT           reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_CONST        reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    QUOTE           reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    $end            reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    RBRACE          reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)
    KW_RETURN       reduce using rule 97 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_NEW LPAREN RPAREN .)


state 257

    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array . RPAREN

    RPAREN          shift and go to state 264


state 258

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array . RPAREN

    RPAREN          shift and go to state 265


state 259

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST . COLON COLON KW_NEW LPAREN RPAREN

    COLON           shift and go to state 266


state 260

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return . RBRACE

    RBRACE          shift and go to state 267


state 261

    (119) return -> main_rule .
    (120) return -> main_rule . KW_RETURN expression_var SEMI

    RBRACE          reduce using rule 119 (return -> main_rule .)
    KW_RETURN       shift and go to state 268


state 262

    (60) array -> KW_LET VARIABLE EQUALS . LBRACKET mdata RBRACKET

    LBRACKET        shift and go to state 118


state 263

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON . KW_NEW LPAREN RPAREN

    KW_NEW          shift and go to state 269


state 264

    (99) hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .

    SEMI            reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_PRINT        reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_LET          reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FN           reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    VARIABLE        reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    LPAREN          reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    LBRACKET        reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FOR          reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_IF           reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_ELSE         reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_WHILE        reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    INTEGER         reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    FLOAT           reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_CONST        reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    QUOTE           reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    $end            reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    RBRACE          reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_RETURN       reduce using rule 99 (hashmap -> KW_LET KW_MUT VARIABLE EQUALS KW_HASHMAP COLON COLON KW_FROM LPAREN array RPAREN .)


state 265

    (108) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .

    SEMI            reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_PRINT        reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_LET          reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FN           reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    VARIABLE        reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    LPAREN          reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    LBRACKET        reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_FOR          reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_IF           reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_ELSE         reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_WHILE        reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    INTEGER         reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    FLOAT           reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_CONST        reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    QUOTE           reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    $end            reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    RBRACE          reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)
    KW_RETURN       reduce using rule 108 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN .)


state 266

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON . COLON KW_NEW LPAREN RPAREN

    COLON           shift and go to state 270


state 267

    (116) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .

    KW_PRINT        reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_LET          reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_FN           reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    VARIABLE        reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    LPAREN          reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    LBRACKET        reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_FOR          reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_IF           reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_ELSE         reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_WHILE        reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    INTEGER         reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    FLOAT           reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_CONST        reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    QUOTE           reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    $end            reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    RBRACE          reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)
    KW_RETURN       reduce using rule 116 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT data_type LBRACE return RBRACE .)


state 268

    (120) return -> main_rule KW_RETURN . expression_var SEMI
    (117) expression_var -> . expression
    (118) expression_var -> . VARIABLE
    (15) expression -> . expression PLUS expression
    (16) expression -> . expression MINUS expression
    (17) expression -> . expression TIMES expression
    (18) expression -> . expression DIVIDE expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . number
    (21) number -> . INTEGER
    (22) number -> . FLOAT
    (23) number -> . VARIABLE

    VARIABLE        shift and go to state 117
    LPAREN          shift and go to state 16
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38

    expression_var                 shift and go to state 271
    expression                     shift and go to state 126
    number                         shift and go to state 26

state 269

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW . LPAREN RPAREN

    LPAREN          shift and go to state 272


state 270

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON . KW_NEW LPAREN RPAREN

    KW_NEW          shift and go to state 273


state 271

    (120) return -> main_rule KW_RETURN expression_var . SEMI

    SEMI            shift and go to state 274


state 272

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN . RPAREN

    RPAREN          shift and go to state 275


state 273

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW . LPAREN RPAREN

    LPAREN          shift and go to state 276


state 274

    (120) return -> main_rule KW_RETURN expression_var SEMI .

    RBRACE          reduce using rule 120 (return -> main_rule KW_RETURN expression_var SEMI .)


state 275

    (105) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .

    SEMI            reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_PRINT        reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_LET          reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FN           reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    VARIABLE        reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    LPAREN          reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    LBRACKET        reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FOR          reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_IF           reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_ELSE         reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_WHILE        reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    INTEGER         reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    FLOAT           reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_CONST        reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    QUOTE           reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    $end            reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    RBRACE          reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_RETURN       reduce using rule 105 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)


state 276

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN . RPAREN

    RPAREN          shift and go to state 277


state 277

    (106) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .

    SEMI            reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_PRINT        reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_LET          reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FN           reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    VARIABLE        reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    LPAREN          reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    LBRACKET        reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_FOR          reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_IF           reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_ELSE         reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_WHILE        reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    INTEGER         reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    FLOAT           reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_CONST        reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    QUOTE           reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    $end            reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    RBRACE          reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)
    KW_RETURN       reduce using rule 106 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT data_type GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for KW_PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 2 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 76 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 76 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 76 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 76 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 76 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 76 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 76 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 82 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 102 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 102 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 102 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 102 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 102 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 102 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 161 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 161 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 161 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 161 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 161 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 161 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 181 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 181 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 181 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 181 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 181 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 181 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 181 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 183 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 183 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 183 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 183 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 183 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 183 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 183 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 204 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 204 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 204 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 204 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 204 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 204 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 204 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 251 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 251 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 251 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_WHILE in state 251 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 251 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 251 resolved as shift
WARNING: shift/reduce conflict for KW_CONST in state 251 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 251 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (main_rule -> father_rule)
WARNING: rejected rule (void -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 11 resolved using rule (father_rule -> array)
WARNING: rejected rule (data_str -> array) in state 11
WARNING: reduce/reduce conflict in state 18 resolved using rule (number -> VARIABLE)
WARNING: rejected rule (variables -> VARIABLE) in state 18
WARNING: reduce/reduce conflict in state 117 resolved using rule (number -> VARIABLE)
WARNING: rejected rule (expression_var -> VARIABLE) in state 117
WARNING: reduce/reduce conflict in state 124 resolved using rule (number -> INTEGER)
WARNING: rejected rule (data -> INTEGER) in state 124
WARNING: reduce/reduce conflict in state 125 resolved using rule (number -> FLOAT)
WARNING: rejected rule (data -> FLOAT) in state 125
WARNING: reduce/reduce conflict in state 190 resolved using rule (number -> INTEGER)
WARNING: rejected rule (data -> INTEGER) in state 190
WARNING: reduce/reduce conflict in state 191 resolved using rule (number -> FLOAT)
WARNING: rejected rule (data -> FLOAT) in state 191
WARNING: Rule (expression_var -> VARIABLE) is never reduced
