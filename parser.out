Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDE
    COMMENT
    DIVEQUAL
    HASH
    KW_ABSTRACT
    KW_AS
    KW_ASYNC
    KW_AWAIT
    KW_BECOME
    KW_BOX
    KW_BREAK
    KW_CHARACTER
    KW_CONST
    KW_CONTINUE
    KW_CRATE
    KW_DO
    KW_DYN
    KW_ENUM
    KW_EXTERN
    KW_FINAL
    KW_IMPL
    KW_LOOP
    KW_MACRO
    KW_MATCH
    KW_MOD
    KW_MOVE
    KW_OVERRIDE
    KW_PRIV
    KW_PUB
    KW_REF
    KW_SELFTYPE
    KW_SELFVALUE
    KW_STATIC
    KW_STATICLIFETIME
    KW_STRUCT
    KW_SUPER
    KW_TRAIT
    KW_TRY
    KW_TYPE
    KW_TYPEOF
    KW_UNION
    KW_UNSAFE
    KW_UNSIZED
    KW_USE
    KW_VIRTUAL
    KW_WHERE
    KW_YIELD
    LNOT
    MINUSEQUAL
    MODULUS
    MODULUSEQUAL
    ORE
    OREXE
    PLUSEQUAL
    QMARK
    RETURN
    TIMESEQUAL

Grammar

Rule 0     S' -> main_rule
Rule 1     main_rule -> father_rule
Rule 2     main_rule -> father_rule main_rule
Rule 3     father_rule -> print
Rule 4     father_rule -> dvariable
Rule 5     father_rule -> array
Rule 6     father_rule -> function
Rule 7     father_rule -> variables
Rule 8     father_rule -> control_str
Rule 9     father_rule -> expression
Rule 10    father_rule -> void
Rule 11    father_rule -> linkedlist
Rule 12    father_rule -> push
Rule 13    father_rule -> remove
Rule 14    father_rule -> if
Rule 15    father_rule -> else
Rule 16    father_rule -> else_if
Rule 17    expression -> expression PLUS expression
Rule 18    expression -> expression MINUS expression
Rule 19    expression -> expression TIMES expression
Rule 20    expression -> expression DIVIDE expression
Rule 21    expression -> LPAREN expression RPAREN
Rule 22    expression -> number
Rule 23    number -> INTEGER
Rule 24    number -> FLOAT
Rule 25    number -> VARIABLE
Rule 26    dataType -> UNSIG_INT_8
Rule 27    dataType -> UNSIG_INT_16
Rule 28    dataType -> UNSIG_INT_32
Rule 29    dataType -> UNSIG_INT_64
Rule 30    dataType -> UNSIG_INT_128
Rule 31    dataType -> SIG_INT_8
Rule 32    dataType -> SIG_INT_16
Rule 33    dataType -> SIG_INT_32
Rule 34    dataType -> SIG_INT_64
Rule 35    dataType -> SIG_INT_128
Rule 36    dataType -> FLOAT_32
Rule 37    dataType -> FLOAT_64
Rule 38    dataType -> KW_BOOLEAN
Rule 39    dataType -> KW_STRING
Rule 40    data -> CADENA
Rule 41    data -> INTEGER
Rule 42    data -> CHAR
Rule 43    data -> FLOAT
Rule 44    data -> KW_FALSE
Rule 45    data -> KW_TRUE
Rule 46    comparator -> <empty>
Rule 47    comparator -> EQ
Rule 48    comparator -> NE
Rule 49    comparator -> GE
Rule 50    comparator -> LE
Rule 51    comparator -> GT
Rule 52    comparator -> LT
Rule 53    and -> VARIABLE LAND VARIABLE
Rule 54    conditional -> VARIABLE comparator data
Rule 55    conditional -> and comparator data
Rule 56    or -> VARIABLE LOR VARIABLE
Rule 57    mdata -> data
Rule 58    mdata -> data COMMA mdata
Rule 59    print -> KW_PRINT LPAREN CADENA RPAREN SEMI
Rule 60    dvariable -> KW_LET VARIABLE SEMI
Rule 61    array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
Rule 62    array -> LBRACKET mdata RBRACKET
Rule 63    variables -> VARIABLE
Rule 64    variables -> VARIABLE COMMA variables
Rule 65    while -> KW_WHILE LPAREN VARIABLE
Rule 66    arguments -> void
Rule 67    arguments -> variables
Rule 68    function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
Rule 69    control_str -> for_str
Rule 70    control_str -> for_str_tagged
Rule 71    for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
Rule 72    for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
Rule 73    for_str_tagged -> label COLON for_str
Rule 74    range -> INTEGER DOT DOT INTEGER
Rule 75    range -> VARIABLE DOT DOT VARIABLE
Rule 76    label -> QUOTE VARIABLE
Rule 77    void -> <empty>
Rule 78    linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
Rule 79    linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
Rule 80    linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
Rule 81    linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
Rule 82    push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI
Rule 83    remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
Rule 84    if -> KW_IF conditional LBRACE main_rule RBRACE
Rule 85    else -> KW_ELSE LBRACE main_rule RBRACE
Rule 86    else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
Rule 87    function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
Rule 88    expression_var -> expression
Rule 89    expression_var -> VARIABLE
Rule 90    return -> main_rule
Rule 91    return -> main_rule KW_RETURN expression_var SEMI

Terminals, with rules where they appear

AND                  : 
ANDE                 : 
CADENA               : 40 59
CHAR                 : 42
COLON                : 73 78 78 78 79 79 79 80 80 81 81
COMMA                : 58 64
COMMENT              : 
DIVEQUAL             : 
DIVIDE               : 20
DOT                  : 74 74 75 75 82 83
EQ                   : 47
EQUALS               : 61 78 79 80 81
FLOAT                : 24 43
FLOAT_32             : 36
FLOAT_64             : 37
GE                   : 49
GT                   : 51 78 79 87
HASH                 : 
INTEGER              : 23 41 74 74 83
KW_ABSTRACT          : 
KW_AS                : 
KW_ASYNC             : 
KW_AWAIT             : 
KW_BECOME            : 
KW_BOOLEAN           : 38
KW_BOX               : 
KW_BREAK             : 
KW_CHARACTER         : 
KW_CONST             : 
KW_CONTINUE          : 
KW_CRATE             : 
KW_DO                : 
KW_DYN               : 
KW_ELSE              : 85 86
KW_ENUM              : 
KW_EXTERN            : 
KW_FALSE             : 44
KW_FINAL             : 
KW_FN                : 68 87
KW_FOR               : 71 72
KW_FROM              : 80 81
KW_IF                : 84 86
KW_IMPL              : 
KW_IN                : 71 72
KW_LET               : 60 61 78 79 80 81
KW_LINKEDLIST        : 78 78 79 79 80 81
KW_LOOP              : 
KW_MACRO             : 
KW_MATCH             : 
KW_MOD               : 
KW_MOVE              : 
KW_MUT               : 79 81
KW_NEW               : 78 79
KW_OVERRIDE          : 
KW_PRINT             : 59
KW_PRIV              : 
KW_PUB               : 
KW_REF               : 
KW_RETURN            : 91
KW_SELFTYPE          : 
KW_SELFVALUE         : 
KW_STATIC            : 
KW_STATICLIFETIME    : 
KW_STRING            : 39
KW_STRUCT            : 
KW_SUPER             : 
KW_TRAIT             : 
KW_TRUE              : 45
KW_TRY               : 
KW_TYPE              : 
KW_TYPEOF            : 
KW_UNION             : 
KW_UNSAFE            : 
KW_UNSIZED           : 
KW_USE               : 
KW_VIRTUAL           : 
KW_WHERE             : 
KW_WHILE             : 65
KW_YIELD             : 
LAND                 : 53
LBRACE               : 68 71 72 84 85 86 87
LBRACKET             : 61 62
LE                   : 50
LNOT                 : 
LOR                  : 56
LPAREN               : 21 59 65 68 78 79 80 81 82 83 87
LT                   : 52 78 79
MINUS                : 18 87
MINUSEQUAL           : 
MODULUS              : 
MODULUSEQUAL         : 
NE                   : 48
ORE                  : 
OREXE                : 
PLUS                 : 17
PLUSEQUAL            : 
PUSH                 : 82
QMARK                : 
QUOTE                : 76
RBRACE               : 68 71 72 84 85 86 87
RBRACKET             : 61 62
REMOVE               : 83
RETURN               : 
RPAREN               : 21 59 68 78 79 80 81 82 83 87
SEMI                 : 59 60 78 79 80 81 82 83 91
SIG_INT_128          : 35
SIG_INT_16           : 32
SIG_INT_32           : 33
SIG_INT_64           : 34
SIG_INT_8            : 31
TIMES                : 19
TIMESEQUAL           : 
UNSIG_INT_128        : 30
UNSIG_INT_16         : 27
UNSIG_INT_32         : 28
UNSIG_INT_64         : 29
UNSIG_INT_8          : 26
VARIABLE             : 25 53 53 54 56 56 60 61 63 64 65 68 71 72 72 75 75 76 78 79 80 81 82 83 87 89
error                : 

Nonterminals, with rules where they appear

and                  : 55
arguments            : 68 87
array                : 5 80 81
comparator           : 54 55
conditional          : 84 86
control_str          : 8
data                 : 54 55 57 58 82
dataType             : 78 79 87
dvariable            : 4
else                 : 15
else_if              : 16
expression           : 9 17 17 18 18 19 19 20 20 21 88
expression_var       : 91
father_rule          : 1 2 68 71 72
for_str              : 69 73
for_str_tagged       : 70
function             : 6
if                   : 14
label                : 73
linkedlist           : 11
main_rule            : 2 84 85 86 90 91 0
mdata                : 58 61 62
number               : 22
or                   : 
print                : 3
push                 : 12
range                : 71
remove               : 13
return               : 87
variables            : 7 64 67
void                 : 10 66
while                : 

Parsing method: LALR

state 0

    (0) S' -> . main_rule
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    $end            reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]

    main_rule                      shift and go to state 1
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 1

    (0) S' -> main_rule .



state 2

    (1) main_rule -> father_rule .
    (2) main_rule -> father_rule . main_rule
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (main_rule -> father_rule .)
  ! reduce/reduce conflict for RBRACE resolved using rule 1 (main_rule -> father_rule .)
  ! reduce/reduce conflict for KW_RETURN resolved using rule 1 (main_rule -> father_rule .)
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    $end            reduce using rule 1 (main_rule -> father_rule .)
    RBRACE          reduce using rule 1 (main_rule -> father_rule .)
    KW_RETURN       reduce using rule 1 (main_rule -> father_rule .)
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]
  ! $end            [ reduce using rule 77 (void -> .) ]
  ! RBRACE          [ reduce using rule 77 (void -> .) ]
  ! KW_RETURN       [ reduce using rule 77 (void -> .) ]

    father_rule                    shift and go to state 2
    main_rule                      shift and go to state 33
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 3

    (3) father_rule -> print .

    KW_PRINT        reduce using rule 3 (father_rule -> print .)
    KW_LET          reduce using rule 3 (father_rule -> print .)
    LBRACKET        reduce using rule 3 (father_rule -> print .)
    KW_FN           reduce using rule 3 (father_rule -> print .)
    VARIABLE        reduce using rule 3 (father_rule -> print .)
    LPAREN          reduce using rule 3 (father_rule -> print .)
    KW_IF           reduce using rule 3 (father_rule -> print .)
    KW_ELSE         reduce using rule 3 (father_rule -> print .)
    KW_FOR          reduce using rule 3 (father_rule -> print .)
    INTEGER         reduce using rule 3 (father_rule -> print .)
    FLOAT           reduce using rule 3 (father_rule -> print .)
    QUOTE           reduce using rule 3 (father_rule -> print .)
    $end            reduce using rule 3 (father_rule -> print .)
    RBRACE          reduce using rule 3 (father_rule -> print .)
    KW_RETURN       reduce using rule 3 (father_rule -> print .)


state 4

    (4) father_rule -> dvariable .

    KW_PRINT        reduce using rule 4 (father_rule -> dvariable .)
    KW_LET          reduce using rule 4 (father_rule -> dvariable .)
    LBRACKET        reduce using rule 4 (father_rule -> dvariable .)
    KW_FN           reduce using rule 4 (father_rule -> dvariable .)
    VARIABLE        reduce using rule 4 (father_rule -> dvariable .)
    LPAREN          reduce using rule 4 (father_rule -> dvariable .)
    KW_IF           reduce using rule 4 (father_rule -> dvariable .)
    KW_ELSE         reduce using rule 4 (father_rule -> dvariable .)
    KW_FOR          reduce using rule 4 (father_rule -> dvariable .)
    INTEGER         reduce using rule 4 (father_rule -> dvariable .)
    FLOAT           reduce using rule 4 (father_rule -> dvariable .)
    QUOTE           reduce using rule 4 (father_rule -> dvariable .)
    $end            reduce using rule 4 (father_rule -> dvariable .)
    RBRACE          reduce using rule 4 (father_rule -> dvariable .)
    KW_RETURN       reduce using rule 4 (father_rule -> dvariable .)


state 5

    (5) father_rule -> array .

    KW_PRINT        reduce using rule 5 (father_rule -> array .)
    KW_LET          reduce using rule 5 (father_rule -> array .)
    LBRACKET        reduce using rule 5 (father_rule -> array .)
    KW_FN           reduce using rule 5 (father_rule -> array .)
    VARIABLE        reduce using rule 5 (father_rule -> array .)
    LPAREN          reduce using rule 5 (father_rule -> array .)
    KW_IF           reduce using rule 5 (father_rule -> array .)
    KW_ELSE         reduce using rule 5 (father_rule -> array .)
    KW_FOR          reduce using rule 5 (father_rule -> array .)
    INTEGER         reduce using rule 5 (father_rule -> array .)
    FLOAT           reduce using rule 5 (father_rule -> array .)
    QUOTE           reduce using rule 5 (father_rule -> array .)
    $end            reduce using rule 5 (father_rule -> array .)
    RBRACE          reduce using rule 5 (father_rule -> array .)
    KW_RETURN       reduce using rule 5 (father_rule -> array .)


state 6

    (6) father_rule -> function .

    KW_PRINT        reduce using rule 6 (father_rule -> function .)
    KW_LET          reduce using rule 6 (father_rule -> function .)
    LBRACKET        reduce using rule 6 (father_rule -> function .)
    KW_FN           reduce using rule 6 (father_rule -> function .)
    VARIABLE        reduce using rule 6 (father_rule -> function .)
    LPAREN          reduce using rule 6 (father_rule -> function .)
    KW_IF           reduce using rule 6 (father_rule -> function .)
    KW_ELSE         reduce using rule 6 (father_rule -> function .)
    KW_FOR          reduce using rule 6 (father_rule -> function .)
    INTEGER         reduce using rule 6 (father_rule -> function .)
    FLOAT           reduce using rule 6 (father_rule -> function .)
    QUOTE           reduce using rule 6 (father_rule -> function .)
    $end            reduce using rule 6 (father_rule -> function .)
    RBRACE          reduce using rule 6 (father_rule -> function .)
    KW_RETURN       reduce using rule 6 (father_rule -> function .)


state 7

    (7) father_rule -> variables .

    KW_PRINT        reduce using rule 7 (father_rule -> variables .)
    KW_LET          reduce using rule 7 (father_rule -> variables .)
    LBRACKET        reduce using rule 7 (father_rule -> variables .)
    KW_FN           reduce using rule 7 (father_rule -> variables .)
    VARIABLE        reduce using rule 7 (father_rule -> variables .)
    LPAREN          reduce using rule 7 (father_rule -> variables .)
    KW_IF           reduce using rule 7 (father_rule -> variables .)
    KW_ELSE         reduce using rule 7 (father_rule -> variables .)
    KW_FOR          reduce using rule 7 (father_rule -> variables .)
    INTEGER         reduce using rule 7 (father_rule -> variables .)
    FLOAT           reduce using rule 7 (father_rule -> variables .)
    QUOTE           reduce using rule 7 (father_rule -> variables .)
    $end            reduce using rule 7 (father_rule -> variables .)
    RBRACE          reduce using rule 7 (father_rule -> variables .)
    KW_RETURN       reduce using rule 7 (father_rule -> variables .)


state 8

    (8) father_rule -> control_str .

    KW_PRINT        reduce using rule 8 (father_rule -> control_str .)
    KW_LET          reduce using rule 8 (father_rule -> control_str .)
    LBRACKET        reduce using rule 8 (father_rule -> control_str .)
    KW_FN           reduce using rule 8 (father_rule -> control_str .)
    VARIABLE        reduce using rule 8 (father_rule -> control_str .)
    LPAREN          reduce using rule 8 (father_rule -> control_str .)
    KW_IF           reduce using rule 8 (father_rule -> control_str .)
    KW_ELSE         reduce using rule 8 (father_rule -> control_str .)
    KW_FOR          reduce using rule 8 (father_rule -> control_str .)
    INTEGER         reduce using rule 8 (father_rule -> control_str .)
    FLOAT           reduce using rule 8 (father_rule -> control_str .)
    QUOTE           reduce using rule 8 (father_rule -> control_str .)
    $end            reduce using rule 8 (father_rule -> control_str .)
    RBRACE          reduce using rule 8 (father_rule -> control_str .)
    KW_RETURN       reduce using rule 8 (father_rule -> control_str .)


state 9

    (9) father_rule -> expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

    KW_PRINT        reduce using rule 9 (father_rule -> expression .)
    KW_LET          reduce using rule 9 (father_rule -> expression .)
    LBRACKET        reduce using rule 9 (father_rule -> expression .)
    KW_FN           reduce using rule 9 (father_rule -> expression .)
    VARIABLE        reduce using rule 9 (father_rule -> expression .)
    LPAREN          reduce using rule 9 (father_rule -> expression .)
    KW_IF           reduce using rule 9 (father_rule -> expression .)
    KW_ELSE         reduce using rule 9 (father_rule -> expression .)
    KW_FOR          reduce using rule 9 (father_rule -> expression .)
    INTEGER         reduce using rule 9 (father_rule -> expression .)
    FLOAT           reduce using rule 9 (father_rule -> expression .)
    QUOTE           reduce using rule 9 (father_rule -> expression .)
    $end            reduce using rule 9 (father_rule -> expression .)
    RBRACE          reduce using rule 9 (father_rule -> expression .)
    KW_RETURN       reduce using rule 9 (father_rule -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37


state 10

    (10) father_rule -> void .

    KW_PRINT        reduce using rule 10 (father_rule -> void .)
    KW_LET          reduce using rule 10 (father_rule -> void .)
    LBRACKET        reduce using rule 10 (father_rule -> void .)
    KW_FN           reduce using rule 10 (father_rule -> void .)
    VARIABLE        reduce using rule 10 (father_rule -> void .)
    LPAREN          reduce using rule 10 (father_rule -> void .)
    KW_IF           reduce using rule 10 (father_rule -> void .)
    KW_ELSE         reduce using rule 10 (father_rule -> void .)
    KW_FOR          reduce using rule 10 (father_rule -> void .)
    INTEGER         reduce using rule 10 (father_rule -> void .)
    FLOAT           reduce using rule 10 (father_rule -> void .)
    QUOTE           reduce using rule 10 (father_rule -> void .)
    $end            reduce using rule 10 (father_rule -> void .)
    RBRACE          reduce using rule 10 (father_rule -> void .)
    KW_RETURN       reduce using rule 10 (father_rule -> void .)


state 11

    (11) father_rule -> linkedlist .

    KW_PRINT        reduce using rule 11 (father_rule -> linkedlist .)
    KW_LET          reduce using rule 11 (father_rule -> linkedlist .)
    LBRACKET        reduce using rule 11 (father_rule -> linkedlist .)
    KW_FN           reduce using rule 11 (father_rule -> linkedlist .)
    VARIABLE        reduce using rule 11 (father_rule -> linkedlist .)
    LPAREN          reduce using rule 11 (father_rule -> linkedlist .)
    KW_IF           reduce using rule 11 (father_rule -> linkedlist .)
    KW_ELSE         reduce using rule 11 (father_rule -> linkedlist .)
    KW_FOR          reduce using rule 11 (father_rule -> linkedlist .)
    INTEGER         reduce using rule 11 (father_rule -> linkedlist .)
    FLOAT           reduce using rule 11 (father_rule -> linkedlist .)
    QUOTE           reduce using rule 11 (father_rule -> linkedlist .)
    $end            reduce using rule 11 (father_rule -> linkedlist .)
    RBRACE          reduce using rule 11 (father_rule -> linkedlist .)
    KW_RETURN       reduce using rule 11 (father_rule -> linkedlist .)


state 12

    (12) father_rule -> push .

    KW_PRINT        reduce using rule 12 (father_rule -> push .)
    KW_LET          reduce using rule 12 (father_rule -> push .)
    LBRACKET        reduce using rule 12 (father_rule -> push .)
    KW_FN           reduce using rule 12 (father_rule -> push .)
    VARIABLE        reduce using rule 12 (father_rule -> push .)
    LPAREN          reduce using rule 12 (father_rule -> push .)
    KW_IF           reduce using rule 12 (father_rule -> push .)
    KW_ELSE         reduce using rule 12 (father_rule -> push .)
    KW_FOR          reduce using rule 12 (father_rule -> push .)
    INTEGER         reduce using rule 12 (father_rule -> push .)
    FLOAT           reduce using rule 12 (father_rule -> push .)
    QUOTE           reduce using rule 12 (father_rule -> push .)
    $end            reduce using rule 12 (father_rule -> push .)
    RBRACE          reduce using rule 12 (father_rule -> push .)
    KW_RETURN       reduce using rule 12 (father_rule -> push .)


state 13

    (13) father_rule -> remove .

    KW_PRINT        reduce using rule 13 (father_rule -> remove .)
    KW_LET          reduce using rule 13 (father_rule -> remove .)
    LBRACKET        reduce using rule 13 (father_rule -> remove .)
    KW_FN           reduce using rule 13 (father_rule -> remove .)
    VARIABLE        reduce using rule 13 (father_rule -> remove .)
    LPAREN          reduce using rule 13 (father_rule -> remove .)
    KW_IF           reduce using rule 13 (father_rule -> remove .)
    KW_ELSE         reduce using rule 13 (father_rule -> remove .)
    KW_FOR          reduce using rule 13 (father_rule -> remove .)
    INTEGER         reduce using rule 13 (father_rule -> remove .)
    FLOAT           reduce using rule 13 (father_rule -> remove .)
    QUOTE           reduce using rule 13 (father_rule -> remove .)
    $end            reduce using rule 13 (father_rule -> remove .)
    RBRACE          reduce using rule 13 (father_rule -> remove .)
    KW_RETURN       reduce using rule 13 (father_rule -> remove .)


state 14

    (14) father_rule -> if .

    KW_PRINT        reduce using rule 14 (father_rule -> if .)
    KW_LET          reduce using rule 14 (father_rule -> if .)
    LBRACKET        reduce using rule 14 (father_rule -> if .)
    KW_FN           reduce using rule 14 (father_rule -> if .)
    VARIABLE        reduce using rule 14 (father_rule -> if .)
    LPAREN          reduce using rule 14 (father_rule -> if .)
    KW_IF           reduce using rule 14 (father_rule -> if .)
    KW_ELSE         reduce using rule 14 (father_rule -> if .)
    KW_FOR          reduce using rule 14 (father_rule -> if .)
    INTEGER         reduce using rule 14 (father_rule -> if .)
    FLOAT           reduce using rule 14 (father_rule -> if .)
    QUOTE           reduce using rule 14 (father_rule -> if .)
    $end            reduce using rule 14 (father_rule -> if .)
    RBRACE          reduce using rule 14 (father_rule -> if .)
    KW_RETURN       reduce using rule 14 (father_rule -> if .)


state 15

    (15) father_rule -> else .

    KW_PRINT        reduce using rule 15 (father_rule -> else .)
    KW_LET          reduce using rule 15 (father_rule -> else .)
    LBRACKET        reduce using rule 15 (father_rule -> else .)
    KW_FN           reduce using rule 15 (father_rule -> else .)
    VARIABLE        reduce using rule 15 (father_rule -> else .)
    LPAREN          reduce using rule 15 (father_rule -> else .)
    KW_IF           reduce using rule 15 (father_rule -> else .)
    KW_ELSE         reduce using rule 15 (father_rule -> else .)
    KW_FOR          reduce using rule 15 (father_rule -> else .)
    INTEGER         reduce using rule 15 (father_rule -> else .)
    FLOAT           reduce using rule 15 (father_rule -> else .)
    QUOTE           reduce using rule 15 (father_rule -> else .)
    $end            reduce using rule 15 (father_rule -> else .)
    RBRACE          reduce using rule 15 (father_rule -> else .)
    KW_RETURN       reduce using rule 15 (father_rule -> else .)


state 16

    (16) father_rule -> else_if .

    KW_PRINT        reduce using rule 16 (father_rule -> else_if .)
    KW_LET          reduce using rule 16 (father_rule -> else_if .)
    LBRACKET        reduce using rule 16 (father_rule -> else_if .)
    KW_FN           reduce using rule 16 (father_rule -> else_if .)
    VARIABLE        reduce using rule 16 (father_rule -> else_if .)
    LPAREN          reduce using rule 16 (father_rule -> else_if .)
    KW_IF           reduce using rule 16 (father_rule -> else_if .)
    KW_ELSE         reduce using rule 16 (father_rule -> else_if .)
    KW_FOR          reduce using rule 16 (father_rule -> else_if .)
    INTEGER         reduce using rule 16 (father_rule -> else_if .)
    FLOAT           reduce using rule 16 (father_rule -> else_if .)
    QUOTE           reduce using rule 16 (father_rule -> else_if .)
    $end            reduce using rule 16 (father_rule -> else_if .)
    RBRACE          reduce using rule 16 (father_rule -> else_if .)
    KW_RETURN       reduce using rule 16 (father_rule -> else_if .)


state 17

    (59) print -> KW_PRINT . LPAREN CADENA RPAREN SEMI

    LPAREN          shift and go to state 38


state 18

    (21) expression -> LPAREN . expression RPAREN
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 40

    expression                     shift and go to state 39
    number                         shift and go to state 25

state 19

    (60) dvariable -> KW_LET . VARIABLE SEMI
    (61) array -> KW_LET . VARIABLE EQUALS LBRACKET mdata RBRACKET
    (78) linkedlist -> KW_LET . VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> KW_LET . KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> KW_LET . VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> KW_LET . KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    VARIABLE        shift and go to state 41
    KW_MUT          shift and go to state 42


state 20

    (63) variables -> VARIABLE .
    (64) variables -> VARIABLE . COMMA variables
    (82) push -> VARIABLE . DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> VARIABLE . DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (25) number -> VARIABLE .

  ! reduce/reduce conflict for KW_PRINT resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_LET resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_FN resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_IF resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_ELSE resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_FOR resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for INTEGER resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for FLOAT resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for QUOTE resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for $end resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 25 (number -> VARIABLE .)
  ! reduce/reduce conflict for KW_RETURN resolved using rule 25 (number -> VARIABLE .)
    COMMA           shift and go to state 43
    DOT             shift and go to state 44
    PLUS            reduce using rule 25 (number -> VARIABLE .)
    MINUS           reduce using rule 25 (number -> VARIABLE .)
    TIMES           reduce using rule 25 (number -> VARIABLE .)
    DIVIDE          reduce using rule 25 (number -> VARIABLE .)
    KW_PRINT        reduce using rule 25 (number -> VARIABLE .)
    KW_LET          reduce using rule 25 (number -> VARIABLE .)
    LBRACKET        reduce using rule 25 (number -> VARIABLE .)
    KW_FN           reduce using rule 25 (number -> VARIABLE .)
    VARIABLE        reduce using rule 25 (number -> VARIABLE .)
    LPAREN          reduce using rule 25 (number -> VARIABLE .)
    KW_IF           reduce using rule 25 (number -> VARIABLE .)
    KW_ELSE         reduce using rule 25 (number -> VARIABLE .)
    KW_FOR          reduce using rule 25 (number -> VARIABLE .)
    INTEGER         reduce using rule 25 (number -> VARIABLE .)
    FLOAT           reduce using rule 25 (number -> VARIABLE .)
    QUOTE           reduce using rule 25 (number -> VARIABLE .)
    $end            reduce using rule 25 (number -> VARIABLE .)
    RBRACE          reduce using rule 25 (number -> VARIABLE .)
    KW_RETURN       reduce using rule 25 (number -> VARIABLE .)

  ! KW_PRINT        [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_LET          [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! LBRACKET        [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_FN           [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! VARIABLE        [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! LPAREN          [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_IF           [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_ELSE         [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_FOR          [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! INTEGER         [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! FLOAT           [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! QUOTE           [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! $end            [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 63 (variables -> VARIABLE .) ]
  ! KW_RETURN       [ reduce using rule 63 (variables -> VARIABLE .) ]


state 21

    (62) array -> LBRACKET . mdata RBRACKET
    (57) mdata -> . data
    (58) mdata -> . data COMMA mdata
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    mdata                          shift and go to state 45
    data                           shift and go to state 46

state 22

    (68) function -> KW_FN . VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> KW_FN . VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE

    VARIABLE        shift and go to state 53


state 23

    (69) control_str -> for_str .

    KW_PRINT        reduce using rule 69 (control_str -> for_str .)
    KW_LET          reduce using rule 69 (control_str -> for_str .)
    LBRACKET        reduce using rule 69 (control_str -> for_str .)
    KW_FN           reduce using rule 69 (control_str -> for_str .)
    VARIABLE        reduce using rule 69 (control_str -> for_str .)
    LPAREN          reduce using rule 69 (control_str -> for_str .)
    KW_IF           reduce using rule 69 (control_str -> for_str .)
    KW_ELSE         reduce using rule 69 (control_str -> for_str .)
    KW_FOR          reduce using rule 69 (control_str -> for_str .)
    INTEGER         reduce using rule 69 (control_str -> for_str .)
    FLOAT           reduce using rule 69 (control_str -> for_str .)
    QUOTE           reduce using rule 69 (control_str -> for_str .)
    $end            reduce using rule 69 (control_str -> for_str .)
    RBRACE          reduce using rule 69 (control_str -> for_str .)
    KW_RETURN       reduce using rule 69 (control_str -> for_str .)


state 24

    (70) control_str -> for_str_tagged .

    KW_PRINT        reduce using rule 70 (control_str -> for_str_tagged .)
    KW_LET          reduce using rule 70 (control_str -> for_str_tagged .)
    LBRACKET        reduce using rule 70 (control_str -> for_str_tagged .)
    KW_FN           reduce using rule 70 (control_str -> for_str_tagged .)
    VARIABLE        reduce using rule 70 (control_str -> for_str_tagged .)
    LPAREN          reduce using rule 70 (control_str -> for_str_tagged .)
    KW_IF           reduce using rule 70 (control_str -> for_str_tagged .)
    KW_ELSE         reduce using rule 70 (control_str -> for_str_tagged .)
    KW_FOR          reduce using rule 70 (control_str -> for_str_tagged .)
    INTEGER         reduce using rule 70 (control_str -> for_str_tagged .)
    FLOAT           reduce using rule 70 (control_str -> for_str_tagged .)
    QUOTE           reduce using rule 70 (control_str -> for_str_tagged .)
    $end            reduce using rule 70 (control_str -> for_str_tagged .)
    RBRACE          reduce using rule 70 (control_str -> for_str_tagged .)
    KW_RETURN       reduce using rule 70 (control_str -> for_str_tagged .)


state 25

    (22) expression -> number .

    PLUS            reduce using rule 22 (expression -> number .)
    MINUS           reduce using rule 22 (expression -> number .)
    TIMES           reduce using rule 22 (expression -> number .)
    DIVIDE          reduce using rule 22 (expression -> number .)
    KW_PRINT        reduce using rule 22 (expression -> number .)
    KW_LET          reduce using rule 22 (expression -> number .)
    LBRACKET        reduce using rule 22 (expression -> number .)
    KW_FN           reduce using rule 22 (expression -> number .)
    VARIABLE        reduce using rule 22 (expression -> number .)
    LPAREN          reduce using rule 22 (expression -> number .)
    KW_IF           reduce using rule 22 (expression -> number .)
    KW_ELSE         reduce using rule 22 (expression -> number .)
    KW_FOR          reduce using rule 22 (expression -> number .)
    INTEGER         reduce using rule 22 (expression -> number .)
    FLOAT           reduce using rule 22 (expression -> number .)
    QUOTE           reduce using rule 22 (expression -> number .)
    $end            reduce using rule 22 (expression -> number .)
    RBRACE          reduce using rule 22 (expression -> number .)
    KW_RETURN       reduce using rule 22 (expression -> number .)
    RPAREN          reduce using rule 22 (expression -> number .)
    SEMI            reduce using rule 22 (expression -> number .)


state 26

    (23) number -> INTEGER .

    PLUS            reduce using rule 23 (number -> INTEGER .)
    MINUS           reduce using rule 23 (number -> INTEGER .)
    TIMES           reduce using rule 23 (number -> INTEGER .)
    DIVIDE          reduce using rule 23 (number -> INTEGER .)
    KW_PRINT        reduce using rule 23 (number -> INTEGER .)
    KW_LET          reduce using rule 23 (number -> INTEGER .)
    LBRACKET        reduce using rule 23 (number -> INTEGER .)
    KW_FN           reduce using rule 23 (number -> INTEGER .)
    VARIABLE        reduce using rule 23 (number -> INTEGER .)
    LPAREN          reduce using rule 23 (number -> INTEGER .)
    KW_IF           reduce using rule 23 (number -> INTEGER .)
    KW_ELSE         reduce using rule 23 (number -> INTEGER .)
    KW_FOR          reduce using rule 23 (number -> INTEGER .)
    INTEGER         reduce using rule 23 (number -> INTEGER .)
    FLOAT           reduce using rule 23 (number -> INTEGER .)
    QUOTE           reduce using rule 23 (number -> INTEGER .)
    $end            reduce using rule 23 (number -> INTEGER .)
    RBRACE          reduce using rule 23 (number -> INTEGER .)
    KW_RETURN       reduce using rule 23 (number -> INTEGER .)
    RPAREN          reduce using rule 23 (number -> INTEGER .)
    SEMI            reduce using rule 23 (number -> INTEGER .)


state 27

    (84) if -> KW_IF . conditional LBRACE main_rule RBRACE
    (54) conditional -> . VARIABLE comparator data
    (55) conditional -> . and comparator data
    (53) and -> . VARIABLE LAND VARIABLE

    VARIABLE        shift and go to state 55

    conditional                    shift and go to state 54
    and                            shift and go to state 56

state 28

    (85) else -> KW_ELSE . LBRACE main_rule RBRACE
    (86) else_if -> KW_ELSE . KW_IF conditional LBRACE main_rule RBRACE

    LBRACE          shift and go to state 57
    KW_IF           shift and go to state 58


state 29

    (71) for_str -> KW_FOR . VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> KW_FOR . VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE

    VARIABLE        shift and go to state 59


state 30

    (73) for_str_tagged -> label . COLON for_str

    COLON           shift and go to state 60


state 31

    (24) number -> FLOAT .

    PLUS            reduce using rule 24 (number -> FLOAT .)
    MINUS           reduce using rule 24 (number -> FLOAT .)
    TIMES           reduce using rule 24 (number -> FLOAT .)
    DIVIDE          reduce using rule 24 (number -> FLOAT .)
    KW_PRINT        reduce using rule 24 (number -> FLOAT .)
    KW_LET          reduce using rule 24 (number -> FLOAT .)
    LBRACKET        reduce using rule 24 (number -> FLOAT .)
    KW_FN           reduce using rule 24 (number -> FLOAT .)
    VARIABLE        reduce using rule 24 (number -> FLOAT .)
    LPAREN          reduce using rule 24 (number -> FLOAT .)
    KW_IF           reduce using rule 24 (number -> FLOAT .)
    KW_ELSE         reduce using rule 24 (number -> FLOAT .)
    KW_FOR          reduce using rule 24 (number -> FLOAT .)
    INTEGER         reduce using rule 24 (number -> FLOAT .)
    FLOAT           reduce using rule 24 (number -> FLOAT .)
    QUOTE           reduce using rule 24 (number -> FLOAT .)
    $end            reduce using rule 24 (number -> FLOAT .)
    RBRACE          reduce using rule 24 (number -> FLOAT .)
    KW_RETURN       reduce using rule 24 (number -> FLOAT .)
    RPAREN          reduce using rule 24 (number -> FLOAT .)
    SEMI            reduce using rule 24 (number -> FLOAT .)


state 32

    (76) label -> QUOTE . VARIABLE

    VARIABLE        shift and go to state 61


state 33

    (2) main_rule -> father_rule main_rule .

    $end            reduce using rule 2 (main_rule -> father_rule main_rule .)
    RBRACE          reduce using rule 2 (main_rule -> father_rule main_rule .)
    KW_RETURN       reduce using rule 2 (main_rule -> father_rule main_rule .)


state 34

    (17) expression -> expression PLUS . expression
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 40

    expression                     shift and go to state 62
    number                         shift and go to state 25

state 35

    (18) expression -> expression MINUS . expression
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 40

    expression                     shift and go to state 63
    number                         shift and go to state 25

state 36

    (19) expression -> expression TIMES . expression
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 40

    expression                     shift and go to state 64
    number                         shift and go to state 25

state 37

    (20) expression -> expression DIVIDE . expression
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 40

    expression                     shift and go to state 65
    number                         shift and go to state 25

state 38

    (59) print -> KW_PRINT LPAREN . CADENA RPAREN SEMI

    CADENA          shift and go to state 66


state 39

    (21) expression -> LPAREN expression . RPAREN
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 67
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37


state 40

    (25) number -> VARIABLE .

    RPAREN          reduce using rule 25 (number -> VARIABLE .)
    PLUS            reduce using rule 25 (number -> VARIABLE .)
    MINUS           reduce using rule 25 (number -> VARIABLE .)
    TIMES           reduce using rule 25 (number -> VARIABLE .)
    DIVIDE          reduce using rule 25 (number -> VARIABLE .)
    KW_PRINT        reduce using rule 25 (number -> VARIABLE .)
    KW_LET          reduce using rule 25 (number -> VARIABLE .)
    LBRACKET        reduce using rule 25 (number -> VARIABLE .)
    KW_FN           reduce using rule 25 (number -> VARIABLE .)
    VARIABLE        reduce using rule 25 (number -> VARIABLE .)
    LPAREN          reduce using rule 25 (number -> VARIABLE .)
    KW_IF           reduce using rule 25 (number -> VARIABLE .)
    KW_ELSE         reduce using rule 25 (number -> VARIABLE .)
    KW_FOR          reduce using rule 25 (number -> VARIABLE .)
    INTEGER         reduce using rule 25 (number -> VARIABLE .)
    FLOAT           reduce using rule 25 (number -> VARIABLE .)
    QUOTE           reduce using rule 25 (number -> VARIABLE .)
    $end            reduce using rule 25 (number -> VARIABLE .)
    RBRACE          reduce using rule 25 (number -> VARIABLE .)
    KW_RETURN       reduce using rule 25 (number -> VARIABLE .)
    SEMI            reduce using rule 25 (number -> VARIABLE .)


state 41

    (60) dvariable -> KW_LET VARIABLE . SEMI
    (61) array -> KW_LET VARIABLE . EQUALS LBRACKET mdata RBRACKET
    (78) linkedlist -> KW_LET VARIABLE . COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> KW_LET VARIABLE . EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    SEMI            shift and go to state 68
    EQUALS          shift and go to state 69
    COLON           shift and go to state 70


state 42

    (79) linkedlist -> KW_LET KW_MUT . VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (81) linkedlist -> KW_LET KW_MUT . VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    VARIABLE        shift and go to state 71


state 43

    (64) variables -> VARIABLE COMMA . variables
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 72

    variables                      shift and go to state 73

state 44

    (82) push -> VARIABLE DOT . PUSH LPAREN data RPAREN SEMI
    (83) remove -> VARIABLE DOT . REMOVE LPAREN INTEGER RPAREN SEMI

    PUSH            shift and go to state 74
    REMOVE          shift and go to state 75


state 45

    (62) array -> LBRACKET mdata . RBRACKET

    RBRACKET        shift and go to state 76


state 46

    (57) mdata -> data .
    (58) mdata -> data . COMMA mdata

    RBRACKET        reduce using rule 57 (mdata -> data .)
    COMMA           shift and go to state 77


state 47

    (40) data -> CADENA .

    COMMA           reduce using rule 40 (data -> CADENA .)
    RBRACKET        reduce using rule 40 (data -> CADENA .)
    LBRACE          reduce using rule 40 (data -> CADENA .)
    RPAREN          reduce using rule 40 (data -> CADENA .)


state 48

    (41) data -> INTEGER .

    COMMA           reduce using rule 41 (data -> INTEGER .)
    RBRACKET        reduce using rule 41 (data -> INTEGER .)
    LBRACE          reduce using rule 41 (data -> INTEGER .)
    RPAREN          reduce using rule 41 (data -> INTEGER .)


state 49

    (42) data -> CHAR .

    COMMA           reduce using rule 42 (data -> CHAR .)
    RBRACKET        reduce using rule 42 (data -> CHAR .)
    LBRACE          reduce using rule 42 (data -> CHAR .)
    RPAREN          reduce using rule 42 (data -> CHAR .)


state 50

    (43) data -> FLOAT .

    COMMA           reduce using rule 43 (data -> FLOAT .)
    RBRACKET        reduce using rule 43 (data -> FLOAT .)
    LBRACE          reduce using rule 43 (data -> FLOAT .)
    RPAREN          reduce using rule 43 (data -> FLOAT .)


state 51

    (44) data -> KW_FALSE .

    COMMA           reduce using rule 44 (data -> KW_FALSE .)
    RBRACKET        reduce using rule 44 (data -> KW_FALSE .)
    LBRACE          reduce using rule 44 (data -> KW_FALSE .)
    RPAREN          reduce using rule 44 (data -> KW_FALSE .)


state 52

    (45) data -> KW_TRUE .

    COMMA           reduce using rule 45 (data -> KW_TRUE .)
    RBRACKET        reduce using rule 45 (data -> KW_TRUE .)
    LBRACE          reduce using rule 45 (data -> KW_TRUE .)
    RPAREN          reduce using rule 45 (data -> KW_TRUE .)


state 53

    (68) function -> KW_FN VARIABLE . LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> KW_FN VARIABLE . LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE

    LPAREN          shift and go to state 78


state 54

    (84) if -> KW_IF conditional . LBRACE main_rule RBRACE

    LBRACE          shift and go to state 79


state 55

    (54) conditional -> VARIABLE . comparator data
    (53) and -> VARIABLE . LAND VARIABLE
    (46) comparator -> .
    (47) comparator -> . EQ
    (48) comparator -> . NE
    (49) comparator -> . GE
    (50) comparator -> . LE
    (51) comparator -> . GT
    (52) comparator -> . LT

    LAND            shift and go to state 81
    CADENA          reduce using rule 46 (comparator -> .)
    INTEGER         reduce using rule 46 (comparator -> .)
    CHAR            reduce using rule 46 (comparator -> .)
    FLOAT           reduce using rule 46 (comparator -> .)
    KW_FALSE        reduce using rule 46 (comparator -> .)
    KW_TRUE         reduce using rule 46 (comparator -> .)
    EQ              shift and go to state 82
    NE              shift and go to state 83
    GE              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87

    comparator                     shift and go to state 80

state 56

    (55) conditional -> and . comparator data
    (46) comparator -> .
    (47) comparator -> . EQ
    (48) comparator -> . NE
    (49) comparator -> . GE
    (50) comparator -> . LE
    (51) comparator -> . GT
    (52) comparator -> . LT

    CADENA          reduce using rule 46 (comparator -> .)
    INTEGER         reduce using rule 46 (comparator -> .)
    CHAR            reduce using rule 46 (comparator -> .)
    FLOAT           reduce using rule 46 (comparator -> .)
    KW_FALSE        reduce using rule 46 (comparator -> .)
    KW_TRUE         reduce using rule 46 (comparator -> .)
    EQ              shift and go to state 82
    NE              shift and go to state 83
    GE              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87

    comparator                     shift and go to state 88

state 57

    (85) else -> KW_ELSE LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]

    main_rule                      shift and go to state 89
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 58

    (86) else_if -> KW_ELSE KW_IF . conditional LBRACE main_rule RBRACE
    (54) conditional -> . VARIABLE comparator data
    (55) conditional -> . and comparator data
    (53) and -> . VARIABLE LAND VARIABLE

    VARIABLE        shift and go to state 55

    conditional                    shift and go to state 90
    and                            shift and go to state 56

state 59

    (71) for_str -> KW_FOR VARIABLE . KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> KW_FOR VARIABLE . KW_IN VARIABLE LBRACE father_rule RBRACE

    KW_IN           shift and go to state 91


state 60

    (73) for_str_tagged -> label COLON . for_str
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE

    KW_FOR          shift and go to state 29

    for_str                        shift and go to state 92

state 61

    (76) label -> QUOTE VARIABLE .

    COLON           reduce using rule 76 (label -> QUOTE VARIABLE .)


state 62

    (17) expression -> expression PLUS expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 17 (expression -> expression PLUS expression .)
    KW_LET          reduce using rule 17 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 17 (expression -> expression PLUS expression .)
    KW_FN           reduce using rule 17 (expression -> expression PLUS expression .)
    VARIABLE        reduce using rule 17 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 17 (expression -> expression PLUS expression .)
    KW_IF           reduce using rule 17 (expression -> expression PLUS expression .)
    KW_ELSE         reduce using rule 17 (expression -> expression PLUS expression .)
    KW_FOR          reduce using rule 17 (expression -> expression PLUS expression .)
    INTEGER         reduce using rule 17 (expression -> expression PLUS expression .)
    FLOAT           reduce using rule 17 (expression -> expression PLUS expression .)
    QUOTE           reduce using rule 17 (expression -> expression PLUS expression .)
    $end            reduce using rule 17 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 17 (expression -> expression PLUS expression .)
    KW_RETURN       reduce using rule 17 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 17 (expression -> expression PLUS expression .)
    SEMI            reduce using rule 17 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 17 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 17 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 17 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 17 (expression -> expression PLUS expression .) ]


state 63

    (18) expression -> expression MINUS expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 18 (expression -> expression MINUS expression .)
    KW_LET          reduce using rule 18 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 18 (expression -> expression MINUS expression .)
    KW_FN           reduce using rule 18 (expression -> expression MINUS expression .)
    VARIABLE        reduce using rule 18 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 18 (expression -> expression MINUS expression .)
    KW_IF           reduce using rule 18 (expression -> expression MINUS expression .)
    KW_ELSE         reduce using rule 18 (expression -> expression MINUS expression .)
    KW_FOR          reduce using rule 18 (expression -> expression MINUS expression .)
    INTEGER         reduce using rule 18 (expression -> expression MINUS expression .)
    FLOAT           reduce using rule 18 (expression -> expression MINUS expression .)
    QUOTE           reduce using rule 18 (expression -> expression MINUS expression .)
    $end            reduce using rule 18 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 18 (expression -> expression MINUS expression .)
    KW_RETURN       reduce using rule 18 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 18 (expression -> expression MINUS expression .)
    SEMI            reduce using rule 18 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 18 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 18 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 18 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> expression MINUS expression .) ]


state 64

    (19) expression -> expression TIMES expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 19 (expression -> expression TIMES expression .)
    KW_LET          reduce using rule 19 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 19 (expression -> expression TIMES expression .)
    KW_FN           reduce using rule 19 (expression -> expression TIMES expression .)
    VARIABLE        reduce using rule 19 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 19 (expression -> expression TIMES expression .)
    KW_IF           reduce using rule 19 (expression -> expression TIMES expression .)
    KW_ELSE         reduce using rule 19 (expression -> expression TIMES expression .)
    KW_FOR          reduce using rule 19 (expression -> expression TIMES expression .)
    INTEGER         reduce using rule 19 (expression -> expression TIMES expression .)
    FLOAT           reduce using rule 19 (expression -> expression TIMES expression .)
    QUOTE           reduce using rule 19 (expression -> expression TIMES expression .)
    $end            reduce using rule 19 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 19 (expression -> expression TIMES expression .)
    KW_RETURN       reduce using rule 19 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 19 (expression -> expression TIMES expression .)
    SEMI            reduce using rule 19 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 19 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 19 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 19 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> expression TIMES expression .) ]


state 65

    (20) expression -> expression DIVIDE expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    KW_PRINT        reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_LET          reduce using rule 20 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_FN           reduce using rule 20 (expression -> expression DIVIDE expression .)
    VARIABLE        reduce using rule 20 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_IF           reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_ELSE         reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_FOR          reduce using rule 20 (expression -> expression DIVIDE expression .)
    INTEGER         reduce using rule 20 (expression -> expression DIVIDE expression .)
    FLOAT           reduce using rule 20 (expression -> expression DIVIDE expression .)
    QUOTE           reduce using rule 20 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 20 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 20 (expression -> expression DIVIDE expression .)
    KW_RETURN       reduce using rule 20 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 20 (expression -> expression DIVIDE expression .)
    SEMI            reduce using rule 20 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 20 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 20 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 20 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 20 (expression -> expression DIVIDE expression .) ]


state 66

    (59) print -> KW_PRINT LPAREN CADENA . RPAREN SEMI

    RPAREN          shift and go to state 93


state 67

    (21) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_PRINT        reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_LET          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_FN           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_IF           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_ELSE         reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_FOR          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    QUOTE           reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    KW_RETURN       reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 21 (expression -> LPAREN expression RPAREN .)
    SEMI            reduce using rule 21 (expression -> LPAREN expression RPAREN .)


state 68

    (60) dvariable -> KW_LET VARIABLE SEMI .

    KW_PRINT        reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_LET          reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    LBRACKET        reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_FN           reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    VARIABLE        reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    LPAREN          reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_IF           reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_ELSE         reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_FOR          reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    INTEGER         reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    FLOAT           reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    QUOTE           reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    $end            reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    RBRACE          reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)
    KW_RETURN       reduce using rule 60 (dvariable -> KW_LET VARIABLE SEMI .)


state 69

    (61) array -> KW_LET VARIABLE EQUALS . LBRACKET mdata RBRACKET
    (80) linkedlist -> KW_LET VARIABLE EQUALS . KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    LBRACKET        shift and go to state 94
    KW_LINKEDLIST   shift and go to state 95


state 70

    (78) linkedlist -> KW_LET VARIABLE COLON . KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    KW_LINKEDLIST   shift and go to state 96


state 71

    (79) linkedlist -> KW_LET KW_MUT VARIABLE . COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (81) linkedlist -> KW_LET KW_MUT VARIABLE . EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    COLON           shift and go to state 97
    EQUALS          shift and go to state 98


state 72

    (63) variables -> VARIABLE .
    (64) variables -> VARIABLE . COMMA variables

    KW_PRINT        reduce using rule 63 (variables -> VARIABLE .)
    KW_LET          reduce using rule 63 (variables -> VARIABLE .)
    LBRACKET        reduce using rule 63 (variables -> VARIABLE .)
    KW_FN           reduce using rule 63 (variables -> VARIABLE .)
    VARIABLE        reduce using rule 63 (variables -> VARIABLE .)
    LPAREN          reduce using rule 63 (variables -> VARIABLE .)
    KW_IF           reduce using rule 63 (variables -> VARIABLE .)
    KW_ELSE         reduce using rule 63 (variables -> VARIABLE .)
    KW_FOR          reduce using rule 63 (variables -> VARIABLE .)
    INTEGER         reduce using rule 63 (variables -> VARIABLE .)
    FLOAT           reduce using rule 63 (variables -> VARIABLE .)
    QUOTE           reduce using rule 63 (variables -> VARIABLE .)
    $end            reduce using rule 63 (variables -> VARIABLE .)
    RBRACE          reduce using rule 63 (variables -> VARIABLE .)
    KW_RETURN       reduce using rule 63 (variables -> VARIABLE .)
    RPAREN          reduce using rule 63 (variables -> VARIABLE .)
    COMMA           shift and go to state 43


state 73

    (64) variables -> VARIABLE COMMA variables .

    KW_PRINT        reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_LET          reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    LBRACKET        reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_FN           reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    VARIABLE        reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    LPAREN          reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_IF           reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_ELSE         reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_FOR          reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    INTEGER         reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    FLOAT           reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    QUOTE           reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    $end            reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    RBRACE          reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    KW_RETURN       reduce using rule 64 (variables -> VARIABLE COMMA variables .)
    RPAREN          reduce using rule 64 (variables -> VARIABLE COMMA variables .)


state 74

    (82) push -> VARIABLE DOT PUSH . LPAREN data RPAREN SEMI

    LPAREN          shift and go to state 99


state 75

    (83) remove -> VARIABLE DOT REMOVE . LPAREN INTEGER RPAREN SEMI

    LPAREN          shift and go to state 100


state 76

    (62) array -> LBRACKET mdata RBRACKET .

    KW_PRINT        reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_LET          reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    LBRACKET        reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_FN           reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    VARIABLE        reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    LPAREN          reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_IF           reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_ELSE         reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_FOR          reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    INTEGER         reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    FLOAT           reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    QUOTE           reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    $end            reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    RBRACE          reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    KW_RETURN       reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)
    RPAREN          reduce using rule 62 (array -> LBRACKET mdata RBRACKET .)


state 77

    (58) mdata -> data COMMA . mdata
    (57) mdata -> . data
    (58) mdata -> . data COMMA mdata
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    data                           shift and go to state 46
    mdata                          shift and go to state 101

state 78

    (68) function -> KW_FN VARIABLE LPAREN . arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> KW_FN VARIABLE LPAREN . arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (66) arguments -> . void
    (67) arguments -> . variables
    (77) void -> .
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables

    RPAREN          reduce using rule 77 (void -> .)
    VARIABLE        shift and go to state 72

    arguments                      shift and go to state 102
    void                           shift and go to state 103
    variables                      shift and go to state 104

state 79

    (84) if -> KW_IF conditional LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]

    main_rule                      shift and go to state 105
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 80

    (54) conditional -> VARIABLE comparator . data
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    data                           shift and go to state 106

state 81

    (53) and -> VARIABLE LAND . VARIABLE

    VARIABLE        shift and go to state 107


state 82

    (47) comparator -> EQ .

    CADENA          reduce using rule 47 (comparator -> EQ .)
    INTEGER         reduce using rule 47 (comparator -> EQ .)
    CHAR            reduce using rule 47 (comparator -> EQ .)
    FLOAT           reduce using rule 47 (comparator -> EQ .)
    KW_FALSE        reduce using rule 47 (comparator -> EQ .)
    KW_TRUE         reduce using rule 47 (comparator -> EQ .)


state 83

    (48) comparator -> NE .

    CADENA          reduce using rule 48 (comparator -> NE .)
    INTEGER         reduce using rule 48 (comparator -> NE .)
    CHAR            reduce using rule 48 (comparator -> NE .)
    FLOAT           reduce using rule 48 (comparator -> NE .)
    KW_FALSE        reduce using rule 48 (comparator -> NE .)
    KW_TRUE         reduce using rule 48 (comparator -> NE .)


state 84

    (49) comparator -> GE .

    CADENA          reduce using rule 49 (comparator -> GE .)
    INTEGER         reduce using rule 49 (comparator -> GE .)
    CHAR            reduce using rule 49 (comparator -> GE .)
    FLOAT           reduce using rule 49 (comparator -> GE .)
    KW_FALSE        reduce using rule 49 (comparator -> GE .)
    KW_TRUE         reduce using rule 49 (comparator -> GE .)


state 85

    (50) comparator -> LE .

    CADENA          reduce using rule 50 (comparator -> LE .)
    INTEGER         reduce using rule 50 (comparator -> LE .)
    CHAR            reduce using rule 50 (comparator -> LE .)
    FLOAT           reduce using rule 50 (comparator -> LE .)
    KW_FALSE        reduce using rule 50 (comparator -> LE .)
    KW_TRUE         reduce using rule 50 (comparator -> LE .)


state 86

    (51) comparator -> GT .

    CADENA          reduce using rule 51 (comparator -> GT .)
    INTEGER         reduce using rule 51 (comparator -> GT .)
    CHAR            reduce using rule 51 (comparator -> GT .)
    FLOAT           reduce using rule 51 (comparator -> GT .)
    KW_FALSE        reduce using rule 51 (comparator -> GT .)
    KW_TRUE         reduce using rule 51 (comparator -> GT .)


state 87

    (52) comparator -> LT .

    CADENA          reduce using rule 52 (comparator -> LT .)
    INTEGER         reduce using rule 52 (comparator -> LT .)
    CHAR            reduce using rule 52 (comparator -> LT .)
    FLOAT           reduce using rule 52 (comparator -> LT .)
    KW_FALSE        reduce using rule 52 (comparator -> LT .)
    KW_TRUE         reduce using rule 52 (comparator -> LT .)


state 88

    (55) conditional -> and comparator . data
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    data                           shift and go to state 108

state 89

    (85) else -> KW_ELSE LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 109


state 90

    (86) else_if -> KW_ELSE KW_IF conditional . LBRACE main_rule RBRACE

    LBRACE          shift and go to state 110


state 91

    (71) for_str -> KW_FOR VARIABLE KW_IN . range LBRACE father_rule RBRACE
    (72) for_str -> KW_FOR VARIABLE KW_IN . VARIABLE LBRACE father_rule RBRACE
    (74) range -> . INTEGER DOT DOT INTEGER
    (75) range -> . VARIABLE DOT DOT VARIABLE

    VARIABLE        shift and go to state 111
    INTEGER         shift and go to state 113

    range                          shift and go to state 112

state 92

    (73) for_str_tagged -> label COLON for_str .

    KW_PRINT        reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_LET          reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    LBRACKET        reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_FN           reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    VARIABLE        reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    LPAREN          reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_IF           reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_ELSE         reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_FOR          reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    INTEGER         reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    FLOAT           reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    QUOTE           reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    $end            reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    RBRACE          reduce using rule 73 (for_str_tagged -> label COLON for_str .)
    KW_RETURN       reduce using rule 73 (for_str_tagged -> label COLON for_str .)


state 93

    (59) print -> KW_PRINT LPAREN CADENA RPAREN . SEMI

    SEMI            shift and go to state 114


state 94

    (61) array -> KW_LET VARIABLE EQUALS LBRACKET . mdata RBRACKET
    (57) mdata -> . data
    (58) mdata -> . data COMMA mdata
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    mdata                          shift and go to state 115
    data                           shift and go to state 46

state 95

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST . COLON COLON KW_FROM LPAREN array RPAREN SEMI

    COLON           shift and go to state 116


state 96

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST . LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    LT              shift and go to state 117


state 97

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON . KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    KW_LINKEDLIST   shift and go to state 118


state 98

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS . KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI

    KW_LINKEDLIST   shift and go to state 119


state 99

    (82) push -> VARIABLE DOT PUSH LPAREN . data RPAREN SEMI
    (40) data -> . CADENA
    (41) data -> . INTEGER
    (42) data -> . CHAR
    (43) data -> . FLOAT
    (44) data -> . KW_FALSE
    (45) data -> . KW_TRUE

    CADENA          shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49
    FLOAT           shift and go to state 50
    KW_FALSE        shift and go to state 51
    KW_TRUE         shift and go to state 52

    data                           shift and go to state 120

state 100

    (83) remove -> VARIABLE DOT REMOVE LPAREN . INTEGER RPAREN SEMI

    INTEGER         shift and go to state 121


state 101

    (58) mdata -> data COMMA mdata .

    RBRACKET        reduce using rule 58 (mdata -> data COMMA mdata .)


state 102

    (68) function -> KW_FN VARIABLE LPAREN arguments . RPAREN LBRACE father_rule RBRACE
    (87) function -> KW_FN VARIABLE LPAREN arguments . RPAREN MINUS GT dataType LBRACE return RBRACE

    RPAREN          shift and go to state 122


state 103

    (66) arguments -> void .

    RPAREN          reduce using rule 66 (arguments -> void .)


state 104

    (67) arguments -> variables .

    RPAREN          reduce using rule 67 (arguments -> variables .)


state 105

    (84) if -> KW_IF conditional LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 123


state 106

    (54) conditional -> VARIABLE comparator data .

    LBRACE          reduce using rule 54 (conditional -> VARIABLE comparator data .)


state 107

    (53) and -> VARIABLE LAND VARIABLE .

    EQ              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    NE              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    GE              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    LE              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    GT              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    LT              reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    CADENA          reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    INTEGER         reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    CHAR            reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    FLOAT           reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    KW_FALSE        reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)
    KW_TRUE         reduce using rule 53 (and -> VARIABLE LAND VARIABLE .)


state 108

    (55) conditional -> and comparator data .

    LBRACE          reduce using rule 55 (conditional -> and comparator data .)


state 109

    (85) else -> KW_ELSE LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    $end            reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 85 (else -> KW_ELSE LBRACE main_rule RBRACE .)


state 110

    (86) else_if -> KW_ELSE KW_IF conditional LBRACE . main_rule RBRACE
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]

    main_rule                      shift and go to state 124
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 111

    (72) for_str -> KW_FOR VARIABLE KW_IN VARIABLE . LBRACE father_rule RBRACE
    (75) range -> VARIABLE . DOT DOT VARIABLE

    LBRACE          shift and go to state 125
    DOT             shift and go to state 126


state 112

    (71) for_str -> KW_FOR VARIABLE KW_IN range . LBRACE father_rule RBRACE

    LBRACE          shift and go to state 127


state 113

    (74) range -> INTEGER . DOT DOT INTEGER

    DOT             shift and go to state 128


state 114

    (59) print -> KW_PRINT LPAREN CADENA RPAREN SEMI .

    KW_PRINT        reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_LET          reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    LBRACKET        reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_FN           reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    VARIABLE        reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    LPAREN          reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_IF           reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_ELSE         reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_FOR          reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    INTEGER         reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    FLOAT           reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    QUOTE           reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    $end            reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    RBRACE          reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)
    KW_RETURN       reduce using rule 59 (print -> KW_PRINT LPAREN CADENA RPAREN SEMI .)


state 115

    (61) array -> KW_LET VARIABLE EQUALS LBRACKET mdata . RBRACKET

    RBRACKET        shift and go to state 129


state 116

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON . COLON KW_FROM LPAREN array RPAREN SEMI

    COLON           shift and go to state 130


state 117

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT . dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (26) dataType -> . UNSIG_INT_8
    (27) dataType -> . UNSIG_INT_16
    (28) dataType -> . UNSIG_INT_32
    (29) dataType -> . UNSIG_INT_64
    (30) dataType -> . UNSIG_INT_128
    (31) dataType -> . SIG_INT_8
    (32) dataType -> . SIG_INT_16
    (33) dataType -> . SIG_INT_32
    (34) dataType -> . SIG_INT_64
    (35) dataType -> . SIG_INT_128
    (36) dataType -> . FLOAT_32
    (37) dataType -> . FLOAT_64
    (38) dataType -> . KW_BOOLEAN
    (39) dataType -> . KW_STRING

    UNSIG_INT_8     shift and go to state 132
    UNSIG_INT_16    shift and go to state 133
    UNSIG_INT_32    shift and go to state 134
    UNSIG_INT_64    shift and go to state 135
    UNSIG_INT_128   shift and go to state 136
    SIG_INT_8       shift and go to state 137
    SIG_INT_16      shift and go to state 138
    SIG_INT_32      shift and go to state 139
    SIG_INT_64      shift and go to state 140
    SIG_INT_128     shift and go to state 141
    FLOAT_32        shift and go to state 142
    FLOAT_64        shift and go to state 143
    KW_BOOLEAN      shift and go to state 144
    KW_STRING       shift and go to state 145

    dataType                       shift and go to state 131

state 118

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST . LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    LT              shift and go to state 146


state 119

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST . COLON COLON KW_FROM LPAREN array RPAREN SEMI

    COLON           shift and go to state 147


state 120

    (82) push -> VARIABLE DOT PUSH LPAREN data . RPAREN SEMI

    RPAREN          shift and go to state 148


state 121

    (83) remove -> VARIABLE DOT REMOVE LPAREN INTEGER . RPAREN SEMI

    RPAREN          shift and go to state 149


state 122

    (68) function -> KW_FN VARIABLE LPAREN arguments RPAREN . LBRACE father_rule RBRACE
    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN . MINUS GT dataType LBRACE return RBRACE

    LBRACE          shift and go to state 150
    MINUS           shift and go to state 151


state 123

    (84) if -> KW_IF conditional LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    $end            reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 84 (if -> KW_IF conditional LBRACE main_rule RBRACE .)


state 124

    (86) else_if -> KW_ELSE KW_IF conditional LBRACE main_rule . RBRACE

    RBRACE          shift and go to state 152


state 125

    (72) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE . father_rule RBRACE
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

    father_rule                    shift and go to state 153
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 126

    (75) range -> VARIABLE DOT . DOT VARIABLE

    DOT             shift and go to state 154


state 127

    (71) for_str -> KW_FOR VARIABLE KW_IN range LBRACE . father_rule RBRACE
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

    father_rule                    shift and go to state 155
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 128

    (74) range -> INTEGER DOT . DOT INTEGER

    DOT             shift and go to state 156


state 129

    (61) array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .

    KW_PRINT        reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_LET          reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    LBRACKET        reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_FN           reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    VARIABLE        reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    LPAREN          reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_IF           reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_ELSE         reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_FOR          reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    INTEGER         reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    FLOAT           reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    QUOTE           reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    $end            reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    RBRACE          reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    KW_RETURN       reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)
    RPAREN          reduce using rule 61 (array -> KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET .)


state 130

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON . KW_FROM LPAREN array RPAREN SEMI

    KW_FROM         shift and go to state 157


state 131

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType . GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    GT              shift and go to state 158


state 132

    (26) dataType -> UNSIG_INT_8 .

    GT              reduce using rule 26 (dataType -> UNSIG_INT_8 .)
    LBRACE          reduce using rule 26 (dataType -> UNSIG_INT_8 .)


state 133

    (27) dataType -> UNSIG_INT_16 .

    GT              reduce using rule 27 (dataType -> UNSIG_INT_16 .)
    LBRACE          reduce using rule 27 (dataType -> UNSIG_INT_16 .)


state 134

    (28) dataType -> UNSIG_INT_32 .

    GT              reduce using rule 28 (dataType -> UNSIG_INT_32 .)
    LBRACE          reduce using rule 28 (dataType -> UNSIG_INT_32 .)


state 135

    (29) dataType -> UNSIG_INT_64 .

    GT              reduce using rule 29 (dataType -> UNSIG_INT_64 .)
    LBRACE          reduce using rule 29 (dataType -> UNSIG_INT_64 .)


state 136

    (30) dataType -> UNSIG_INT_128 .

    GT              reduce using rule 30 (dataType -> UNSIG_INT_128 .)
    LBRACE          reduce using rule 30 (dataType -> UNSIG_INT_128 .)


state 137

    (31) dataType -> SIG_INT_8 .

    GT              reduce using rule 31 (dataType -> SIG_INT_8 .)
    LBRACE          reduce using rule 31 (dataType -> SIG_INT_8 .)


state 138

    (32) dataType -> SIG_INT_16 .

    GT              reduce using rule 32 (dataType -> SIG_INT_16 .)
    LBRACE          reduce using rule 32 (dataType -> SIG_INT_16 .)


state 139

    (33) dataType -> SIG_INT_32 .

    GT              reduce using rule 33 (dataType -> SIG_INT_32 .)
    LBRACE          reduce using rule 33 (dataType -> SIG_INT_32 .)


state 140

    (34) dataType -> SIG_INT_64 .

    GT              reduce using rule 34 (dataType -> SIG_INT_64 .)
    LBRACE          reduce using rule 34 (dataType -> SIG_INT_64 .)


state 141

    (35) dataType -> SIG_INT_128 .

    GT              reduce using rule 35 (dataType -> SIG_INT_128 .)
    LBRACE          reduce using rule 35 (dataType -> SIG_INT_128 .)


state 142

    (36) dataType -> FLOAT_32 .

    GT              reduce using rule 36 (dataType -> FLOAT_32 .)
    LBRACE          reduce using rule 36 (dataType -> FLOAT_32 .)


state 143

    (37) dataType -> FLOAT_64 .

    GT              reduce using rule 37 (dataType -> FLOAT_64 .)
    LBRACE          reduce using rule 37 (dataType -> FLOAT_64 .)


state 144

    (38) dataType -> KW_BOOLEAN .

    GT              reduce using rule 38 (dataType -> KW_BOOLEAN .)
    LBRACE          reduce using rule 38 (dataType -> KW_BOOLEAN .)


state 145

    (39) dataType -> KW_STRING .

    GT              reduce using rule 39 (dataType -> KW_STRING .)
    LBRACE          reduce using rule 39 (dataType -> KW_STRING .)


state 146

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT . dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (26) dataType -> . UNSIG_INT_8
    (27) dataType -> . UNSIG_INT_16
    (28) dataType -> . UNSIG_INT_32
    (29) dataType -> . UNSIG_INT_64
    (30) dataType -> . UNSIG_INT_128
    (31) dataType -> . SIG_INT_8
    (32) dataType -> . SIG_INT_16
    (33) dataType -> . SIG_INT_32
    (34) dataType -> . SIG_INT_64
    (35) dataType -> . SIG_INT_128
    (36) dataType -> . FLOAT_32
    (37) dataType -> . FLOAT_64
    (38) dataType -> . KW_BOOLEAN
    (39) dataType -> . KW_STRING

    UNSIG_INT_8     shift and go to state 132
    UNSIG_INT_16    shift and go to state 133
    UNSIG_INT_32    shift and go to state 134
    UNSIG_INT_64    shift and go to state 135
    UNSIG_INT_128   shift and go to state 136
    SIG_INT_8       shift and go to state 137
    SIG_INT_16      shift and go to state 138
    SIG_INT_32      shift and go to state 139
    SIG_INT_64      shift and go to state 140
    SIG_INT_128     shift and go to state 141
    FLOAT_32        shift and go to state 142
    FLOAT_64        shift and go to state 143
    KW_BOOLEAN      shift and go to state 144
    KW_STRING       shift and go to state 145

    dataType                       shift and go to state 159

state 147

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON . COLON KW_FROM LPAREN array RPAREN SEMI

    COLON           shift and go to state 160


state 148

    (82) push -> VARIABLE DOT PUSH LPAREN data RPAREN . SEMI

    SEMI            shift and go to state 161


state 149

    (83) remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN . SEMI

    SEMI            shift and go to state 162


state 150

    (68) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE . father_rule RBRACE
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

    father_rule                    shift and go to state 163
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 151

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS . GT dataType LBRACE return RBRACE

    GT              shift and go to state 164


state 152

    (86) else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .

    KW_PRINT        reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_LET          reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    LBRACKET        reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FN           reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    VARIABLE        reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    LPAREN          reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_IF           reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_ELSE         reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_FOR          reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    INTEGER         reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    FLOAT           reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    QUOTE           reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    $end            reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    RBRACE          reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)
    KW_RETURN       reduce using rule 86 (else_if -> KW_ELSE KW_IF conditional LBRACE main_rule RBRACE .)


state 153

    (72) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule . RBRACE

    RBRACE          shift and go to state 165


state 154

    (75) range -> VARIABLE DOT DOT . VARIABLE

    VARIABLE        shift and go to state 166


state 155

    (71) for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule . RBRACE

    RBRACE          shift and go to state 167


state 156

    (74) range -> INTEGER DOT DOT . INTEGER

    INTEGER         shift and go to state 168


state 157

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM . LPAREN array RPAREN SEMI

    LPAREN          shift and go to state 169


state 158

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT . EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    EQUALS          shift and go to state 170


state 159

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType . GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    GT              shift and go to state 171


state 160

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON . KW_FROM LPAREN array RPAREN SEMI

    KW_FROM         shift and go to state 172


state 161

    (82) push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .

    KW_PRINT        reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_LET          reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    LBRACKET        reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_FN           reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    VARIABLE        reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    LPAREN          reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_IF           reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_ELSE         reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_FOR          reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    INTEGER         reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    FLOAT           reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    QUOTE           reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    $end            reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    RBRACE          reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)
    KW_RETURN       reduce using rule 82 (push -> VARIABLE DOT PUSH LPAREN data RPAREN SEMI .)


state 162

    (83) remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .

    KW_PRINT        reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_LET          reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    LBRACKET        reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_FN           reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    VARIABLE        reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    LPAREN          reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_IF           reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_ELSE         reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_FOR          reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    INTEGER         reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    FLOAT           reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    QUOTE           reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    $end            reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    RBRACE          reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)
    KW_RETURN       reduce using rule 83 (remove -> VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI .)


state 163

    (68) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule . RBRACE

    RBRACE          shift and go to state 173


state 164

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT . dataType LBRACE return RBRACE
    (26) dataType -> . UNSIG_INT_8
    (27) dataType -> . UNSIG_INT_16
    (28) dataType -> . UNSIG_INT_32
    (29) dataType -> . UNSIG_INT_64
    (30) dataType -> . UNSIG_INT_128
    (31) dataType -> . SIG_INT_8
    (32) dataType -> . SIG_INT_16
    (33) dataType -> . SIG_INT_32
    (34) dataType -> . SIG_INT_64
    (35) dataType -> . SIG_INT_128
    (36) dataType -> . FLOAT_32
    (37) dataType -> . FLOAT_64
    (38) dataType -> . KW_BOOLEAN
    (39) dataType -> . KW_STRING

    UNSIG_INT_8     shift and go to state 132
    UNSIG_INT_16    shift and go to state 133
    UNSIG_INT_32    shift and go to state 134
    UNSIG_INT_64    shift and go to state 135
    UNSIG_INT_128   shift and go to state 136
    SIG_INT_8       shift and go to state 137
    SIG_INT_16      shift and go to state 138
    SIG_INT_32      shift and go to state 139
    SIG_INT_64      shift and go to state 140
    SIG_INT_128     shift and go to state 141
    FLOAT_32        shift and go to state 142
    FLOAT_64        shift and go to state 143
    KW_BOOLEAN      shift and go to state 144
    KW_STRING       shift and go to state 145

    dataType                       shift and go to state 174

state 165

    (72) for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .

    KW_PRINT        reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_LET          reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    LBRACKET        reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_FN           reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    VARIABLE        reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    LPAREN          reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_IF           reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_ELSE         reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_FOR          reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    INTEGER         reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    FLOAT           reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    QUOTE           reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    $end            reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    RBRACE          reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)
    KW_RETURN       reduce using rule 72 (for_str -> KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE .)


state 166

    (75) range -> VARIABLE DOT DOT VARIABLE .

    LBRACE          reduce using rule 75 (range -> VARIABLE DOT DOT VARIABLE .)


state 167

    (71) for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .

    KW_PRINT        reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_LET          reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    LBRACKET        reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_FN           reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    VARIABLE        reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    LPAREN          reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_IF           reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_ELSE         reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_FOR          reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    INTEGER         reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    FLOAT           reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    QUOTE           reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    $end            reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    RBRACE          reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)
    KW_RETURN       reduce using rule 71 (for_str -> KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE .)


state 168

    (74) range -> INTEGER DOT DOT INTEGER .

    LBRACE          reduce using rule 74 (range -> INTEGER DOT DOT INTEGER .)


state 169

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN . array RPAREN SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 175
    LBRACKET        shift and go to state 21

    array                          shift and go to state 176

state 170

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS . KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    KW_LINKEDLIST   shift and go to state 177


state 171

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT . EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    EQUALS          shift and go to state 178


state 172

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM . LPAREN array RPAREN SEMI

    LPAREN          shift and go to state 179


state 173

    (68) function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .

    KW_PRINT        reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_LET          reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    LBRACKET        reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_FN           reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    VARIABLE        reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    LPAREN          reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_IF           reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_ELSE         reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_FOR          reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    INTEGER         reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    FLOAT           reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    QUOTE           reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    $end            reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    RBRACE          reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)
    KW_RETURN       reduce using rule 68 (function -> KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE .)


state 174

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType . LBRACE return RBRACE

    LBRACE          shift and go to state 180


state 175

    (61) array -> KW_LET . VARIABLE EQUALS LBRACKET mdata RBRACKET

    VARIABLE        shift and go to state 181


state 176

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array . RPAREN SEMI

    RPAREN          shift and go to state 182


state 177

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST . COLON COLON KW_NEW LPAREN RPAREN SEMI

    COLON           shift and go to state 183


state 178

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS . KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI

    KW_LINKEDLIST   shift and go to state 184


state 179

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN . array RPAREN SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET

    KW_LET          shift and go to state 175
    LBRACKET        shift and go to state 21

    array                          shift and go to state 185

state 180

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE . return RBRACE
    (90) return -> . main_rule
    (91) return -> . main_rule KW_RETURN expression_var SEMI
    (1) main_rule -> . father_rule
    (2) main_rule -> . father_rule main_rule
    (3) father_rule -> . print
    (4) father_rule -> . dvariable
    (5) father_rule -> . array
    (6) father_rule -> . function
    (7) father_rule -> . variables
    (8) father_rule -> . control_str
    (9) father_rule -> . expression
    (10) father_rule -> . void
    (11) father_rule -> . linkedlist
    (12) father_rule -> . push
    (13) father_rule -> . remove
    (14) father_rule -> . if
    (15) father_rule -> . else
    (16) father_rule -> . else_if
    (59) print -> . KW_PRINT LPAREN CADENA RPAREN SEMI
    (60) dvariable -> . KW_LET VARIABLE SEMI
    (61) array -> . KW_LET VARIABLE EQUALS LBRACKET mdata RBRACKET
    (62) array -> . LBRACKET mdata RBRACKET
    (68) function -> . KW_FN VARIABLE LPAREN arguments RPAREN LBRACE father_rule RBRACE
    (87) function -> . KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE
    (63) variables -> . VARIABLE
    (64) variables -> . VARIABLE COMMA variables
    (69) control_str -> . for_str
    (70) control_str -> . for_str_tagged
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (77) void -> .
    (78) linkedlist -> . KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (79) linkedlist -> . KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI
    (80) linkedlist -> . KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (81) linkedlist -> . KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI
    (82) push -> . VARIABLE DOT PUSH LPAREN data RPAREN SEMI
    (83) remove -> . VARIABLE DOT REMOVE LPAREN INTEGER RPAREN SEMI
    (84) if -> . KW_IF conditional LBRACE main_rule RBRACE
    (85) else -> . KW_ELSE LBRACE main_rule RBRACE
    (86) else_if -> . KW_ELSE KW_IF conditional LBRACE main_rule RBRACE
    (71) for_str -> . KW_FOR VARIABLE KW_IN range LBRACE father_rule RBRACE
    (72) for_str -> . KW_FOR VARIABLE KW_IN VARIABLE LBRACE father_rule RBRACE
    (73) for_str_tagged -> . label COLON for_str
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE
    (76) label -> . QUOTE VARIABLE

  ! shift/reduce conflict for KW_PRINT resolved as shift
  ! shift/reduce conflict for KW_LET resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for KW_FN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for KW_IF resolved as shift
  ! shift/reduce conflict for KW_ELSE resolved as shift
  ! shift/reduce conflict for KW_FOR resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for QUOTE resolved as shift
    KW_PRINT        shift and go to state 17
    KW_LET          shift and go to state 19
    LBRACKET        shift and go to state 21
    KW_FN           shift and go to state 22
    VARIABLE        shift and go to state 20
    LPAREN          shift and go to state 18
    KW_RETURN       reduce using rule 77 (void -> .)
    RBRACE          reduce using rule 77 (void -> .)
    KW_IF           shift and go to state 27
    KW_ELSE         shift and go to state 28
    KW_FOR          shift and go to state 29
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31
    QUOTE           shift and go to state 32

  ! KW_PRINT        [ reduce using rule 77 (void -> .) ]
  ! KW_LET          [ reduce using rule 77 (void -> .) ]
  ! LBRACKET        [ reduce using rule 77 (void -> .) ]
  ! KW_FN           [ reduce using rule 77 (void -> .) ]
  ! VARIABLE        [ reduce using rule 77 (void -> .) ]
  ! LPAREN          [ reduce using rule 77 (void -> .) ]
  ! KW_IF           [ reduce using rule 77 (void -> .) ]
  ! KW_ELSE         [ reduce using rule 77 (void -> .) ]
  ! KW_FOR          [ reduce using rule 77 (void -> .) ]
  ! INTEGER         [ reduce using rule 77 (void -> .) ]
  ! FLOAT           [ reduce using rule 77 (void -> .) ]
  ! QUOTE           [ reduce using rule 77 (void -> .) ]

    return                         shift and go to state 186
    main_rule                      shift and go to state 187
    father_rule                    shift and go to state 2
    print                          shift and go to state 3
    dvariable                      shift and go to state 4
    array                          shift and go to state 5
    function                       shift and go to state 6
    variables                      shift and go to state 7
    control_str                    shift and go to state 8
    expression                     shift and go to state 9
    void                           shift and go to state 10
    linkedlist                     shift and go to state 11
    push                           shift and go to state 12
    remove                         shift and go to state 13
    if                             shift and go to state 14
    else                           shift and go to state 15
    else_if                        shift and go to state 16
    for_str                        shift and go to state 23
    for_str_tagged                 shift and go to state 24
    number                         shift and go to state 25
    label                          shift and go to state 30

state 181

    (61) array -> KW_LET VARIABLE . EQUALS LBRACKET mdata RBRACKET

    EQUALS          shift and go to state 188


state 182

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN . SEMI

    SEMI            shift and go to state 189


state 183

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON . COLON KW_NEW LPAREN RPAREN SEMI

    COLON           shift and go to state 190


state 184

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST . COLON COLON KW_NEW LPAREN RPAREN SEMI

    COLON           shift and go to state 191


state 185

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array . RPAREN SEMI

    RPAREN          shift and go to state 192


state 186

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return . RBRACE

    RBRACE          shift and go to state 193


state 187

    (90) return -> main_rule .
    (91) return -> main_rule . KW_RETURN expression_var SEMI

    RBRACE          reduce using rule 90 (return -> main_rule .)
    KW_RETURN       shift and go to state 194


state 188

    (61) array -> KW_LET VARIABLE EQUALS . LBRACKET mdata RBRACKET

    LBRACKET        shift and go to state 94


state 189

    (80) linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .

    KW_PRINT        reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_LET          reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    LBRACKET        reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_FN           reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    VARIABLE        reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    LPAREN          reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_IF           reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_ELSE         reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_FOR          reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    INTEGER         reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    FLOAT           reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    QUOTE           reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    $end            reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    RBRACE          reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_RETURN       reduce using rule 80 (linkedlist -> KW_LET VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)


state 190

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON . KW_NEW LPAREN RPAREN SEMI

    KW_NEW          shift and go to state 195


state 191

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON . COLON KW_NEW LPAREN RPAREN SEMI

    COLON           shift and go to state 196


state 192

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN . SEMI

    SEMI            shift and go to state 197


state 193

    (87) function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .

    KW_PRINT        reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_LET          reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    LBRACKET        reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_FN           reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    VARIABLE        reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    LPAREN          reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_IF           reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_ELSE         reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_FOR          reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    INTEGER         reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    FLOAT           reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    QUOTE           reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    $end            reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    RBRACE          reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)
    KW_RETURN       reduce using rule 87 (function -> KW_FN VARIABLE LPAREN arguments RPAREN MINUS GT dataType LBRACE return RBRACE .)


state 194

    (91) return -> main_rule KW_RETURN . expression_var SEMI
    (88) expression_var -> . expression
    (89) expression_var -> . VARIABLE
    (17) expression -> . expression PLUS expression
    (18) expression -> . expression MINUS expression
    (19) expression -> . expression TIMES expression
    (20) expression -> . expression DIVIDE expression
    (21) expression -> . LPAREN expression RPAREN
    (22) expression -> . number
    (23) number -> . INTEGER
    (24) number -> . FLOAT
    (25) number -> . VARIABLE

    VARIABLE        shift and go to state 200
    LPAREN          shift and go to state 18
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 31

    expression_var                 shift and go to state 198
    expression                     shift and go to state 199
    number                         shift and go to state 25

state 195

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 201


state 196

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON . KW_NEW LPAREN RPAREN SEMI

    KW_NEW          shift and go to state 202


state 197

    (81) linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .

    KW_PRINT        reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_LET          reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    LBRACKET        reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_FN           reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    VARIABLE        reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    LPAREN          reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_IF           reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_ELSE         reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_FOR          reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    INTEGER         reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    FLOAT           reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    QUOTE           reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    $end            reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    RBRACE          reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)
    KW_RETURN       reduce using rule 81 (linkedlist -> KW_LET KW_MUT VARIABLE EQUALS KW_LINKEDLIST COLON COLON KW_FROM LPAREN array RPAREN SEMI .)


state 198

    (91) return -> main_rule KW_RETURN expression_var . SEMI

    SEMI            shift and go to state 203


state 199

    (88) expression_var -> expression .
    (17) expression -> expression . PLUS expression
    (18) expression -> expression . MINUS expression
    (19) expression -> expression . TIMES expression
    (20) expression -> expression . DIVIDE expression

    SEMI            reduce using rule 88 (expression_var -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 37


state 200

    (89) expression_var -> VARIABLE .
    (25) number -> VARIABLE .

  ! reduce/reduce conflict for SEMI resolved using rule 25 (number -> VARIABLE .)
    PLUS            reduce using rule 25 (number -> VARIABLE .)
    MINUS           reduce using rule 25 (number -> VARIABLE .)
    TIMES           reduce using rule 25 (number -> VARIABLE .)
    DIVIDE          reduce using rule 25 (number -> VARIABLE .)
    SEMI            reduce using rule 25 (number -> VARIABLE .)

  ! SEMI            [ reduce using rule 89 (expression_var -> VARIABLE .) ]


state 201

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 204


state 202

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 205


state 203

    (91) return -> main_rule KW_RETURN expression_var SEMI .

    RBRACE          reduce using rule 91 (return -> main_rule KW_RETURN expression_var SEMI .)


state 204

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN . SEMI

    SEMI            shift and go to state 206


state 205

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 207


state 206

    (78) linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .

    KW_PRINT        reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_LET          reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    LBRACKET        reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_FN           reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    VARIABLE        reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    LPAREN          reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_IF           reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_ELSE         reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_FOR          reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    INTEGER         reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    FLOAT           reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    QUOTE           reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    $end            reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    RBRACE          reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_RETURN       reduce using rule 78 (linkedlist -> KW_LET VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)


state 207

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN . SEMI

    SEMI            shift and go to state 208


state 208

    (79) linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .

    KW_PRINT        reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_LET          reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    LBRACKET        reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_FN           reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    VARIABLE        reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    LPAREN          reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_IF           reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_ELSE         reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_FOR          reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    INTEGER         reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    FLOAT           reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    QUOTE           reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    $end            reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    RBRACE          reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)
    KW_RETURN       reduce using rule 79 (linkedlist -> KW_LET KW_MUT VARIABLE COLON KW_LINKEDLIST LT dataType GT EQUALS KW_LINKEDLIST COLON COLON KW_NEW LPAREN RPAREN SEMI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for KW_PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 0 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 2 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 2 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 57 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 57 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 57 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 57 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 57 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 57 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 57 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 57 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 57 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 62 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 62 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 79 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 79 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 79 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 79 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 79 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 79 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 79 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 110 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 110 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 110 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 110 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 110 resolved as shift
WARNING: shift/reduce conflict for KW_PRINT in state 180 resolved as shift
WARNING: shift/reduce conflict for KW_LET in state 180 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 180 resolved as shift
WARNING: shift/reduce conflict for KW_FN in state 180 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 180 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 180 resolved as shift
WARNING: shift/reduce conflict for KW_IF in state 180 resolved as shift
WARNING: shift/reduce conflict for KW_ELSE in state 180 resolved as shift
WARNING: shift/reduce conflict for KW_FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 180 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 180 resolved as shift
WARNING: shift/reduce conflict for QUOTE in state 180 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (main_rule -> father_rule)
WARNING: rejected rule (void -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 20 resolved using rule (number -> VARIABLE)
WARNING: rejected rule (variables -> VARIABLE) in state 20
WARNING: reduce/reduce conflict in state 200 resolved using rule (number -> VARIABLE)
WARNING: rejected rule (expression_var -> VARIABLE) in state 200
WARNING: Rule (expression_var -> VARIABLE) is never reduced
